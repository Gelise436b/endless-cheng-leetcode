# LeetCode 灵神题单精研笔记  
> **从范式启航，向思维深处漫溯**  

---

## 📅 学习日志  
## 📚 目录

- [📅 Day 1 - 滑动窗口启航：定长窗口的元音之眼](#day-1---滑动窗口启航定长窗口的元音之眼)
- [📅 Day 2 - 滑动窗口深化：定长平均值的三重奏](#day-2---滑动窗口深化定长平均值的三重奏)
- [📅 Day 3 - 滑动窗口进阶：条件判定与哈希协同](#day-3---滑动窗口进阶条件判定与哈希协同)
- [📅 Day 4 - 滑动窗口深化：逆向思维与边界转化](#day-4---滑动窗口深化逆向思维与边界转化)
- [📅 Day 5 - 滑动窗口高阶应用：剩余集维护与问题建模再校准](#day-5---滑动窗口高阶应用剩余集维护与问题建模再校准)
- [📅 Day 6 - 滑动窗口的语义建模与状态分离策略](#day-6---滑动窗口的语义建模与状态分离策略)
- [📅 Day 7 - 回归基础与认知边界校准](#day-7---回归基础与认知边界校准)
- [📅 Day 8 - 不定长滑动窗口的建模与逆向思维训练](#day-8---不定长滑动窗口的建模与逆向思维训练)
- [📅 Day 9 - 不定长滑动窗口的深化与“问题本质识别”训练](#day-9---不定长滑动窗口的深化与问题本质识别训练)
- [📅 Day 10 - 不定长滑动窗口的「频次-二分」双形态巩固](#day-10---不定长滑动窗口的频次-二分双形态巩固)
- [📅 Day 11 - 逆向思维转化与状态维护的精准性](#day-11---逆向思维转化与状态维护的精准性)
- [📅 Day 12 - 逆向补集思维与宏观数学视野](#day-12---逆向补集思维与宏观数学视野)
- [📅 Day 13 - 滑窗内的“计数原理”与逻辑修正](#day-13---滑窗内的计数原理与逻辑修正)
- [📅Day 14 - 滑窗计数进阶与逻辑陷阱修复](#day-14---滑窗计数进阶与逻辑陷阱修复)
- [📅Day 15 - 逆向思维：从“至多”跨越到“至少”](#day-15---逆向思维从至多跨越到至少)
- [📅Day 16 - 组合数学与状态压缩：破解“复杂条件”滑窗](#day16---组合数学与状态压缩破解复杂条件滑窗)
---

### Day 1 - 滑动窗口启航：定长窗口的元音之眼  
- **完成题目**：  
  - [x] [1456] 定长子串中元音的最大数目  

- **学习重点**：  
  - 掌握**固定长度滑动窗口的标准维护流程**：右端点扩展 → 窗口满时更新答案 → 左端点收缩；  
  - 理解**窗口有效性判断的核心条件**：`left = i - k + 1 ≥ 0` 是窗口达到长度 `k` 的充要标志；  
  - 实践**增量维护思想**：仅通过加入新字符、移出旧字符，避免重复遍历子串，实现 O(1) 状态转移；  
  - 初识**早停优化策略**：当当前窗口元音数已达理论最大值 `k` 时，可提前终止循环。  

- **卡点反思**：  
  - 初写时混淆了**左端点移出的时机**：曾错误地在更新答案前就执行 `vowel--`，导致当前窗口状态被破坏；  
  - 对“窗口未满时不更新答案”的逻辑缺乏警惕，一度在 `i < k-1` 时也尝试 `max(ans, vowel)`，引入无效比较；  
  - 虽能写出正确代码，但对**为何必须先更新答案再移出左端**的理解停留在“照着模板写”，未从“窗口生命周期”角度内化。  

- **收获与改进**：  
  - 明确了**固定窗口的三步原子操作顺序**：  
    1. **纳入右端**（无条件）；  
    2. **若窗口有效，则更新全局答案**；  
    3. **为下一轮准备，移出左端**（仅当窗口已满）；  
  - 建立了**窗口即状态容器**的认知：窗口内容由左右指针界定，其内部统计量（如元音数）需随指针移动同步更新；  
  - 意识到**边界即正确性**：`left = i - k + 1` 这一简单公式，实则是连接索引与窗口语义的桥梁，未来需对其保持高度敏感；  
  - 已整理详细笔记：[《定长子串中元音的最大数目》](https://github.com/Gelise436b/endless-cheng-leetcode/blob/main/sliding-window/%E5%AE%9A%E9%95%BF%E5%AD%90%E4%B8%B2%E4%B8%AD%E5%85%83%E9%9F%B3%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE.md)  

- **明日计划**：  
  - 手写 [1456] 的 C++ 实现三遍，重点默写窗口边界判断与左右端操作顺序；  
  - 推进灵神题单滑动窗口模块：  
    - [643] 子数组最大平均数 I（巩固定长窗口 + 浮点处理）  
    - [1004] 最大连续1的个数 III（进阶：可变窗口 + 条件松弛）  
  - 开始构建**滑动窗口问题识别 checklist**：  
    - 是否涉及“连续子数组/子串”？  
    - 是否有“长度固定”或“满足某条件的最长/最短”等关键词？  
    - 能否通过左右指针移动维护一个有效区间？  

### Day 2 - 滑动窗口深化：定长平均值的三重奏  
- **完成题目**：  
  - [x] [643] 子数组最大平均数 I  
  - [x] [1343] 大小为 K 且平均值大于等于阈值的子数组数目  
  - [x] [2090] 半径为 k 的子数组平均值  

- **学习重点**：  
  - 提炼并固化**定长滑动窗口的通用三步法**：  
    1. **进入**：无条件纳入右端点元素；  
    2. **更新**：当窗口达到目标长度时，基于当前窗口状态更新答案；  
    3. **退出**：为下一轮迭代准备，移出最左侧元素（仅在窗口已满后执行）；  
  - 掌握**窗口长度与索引关系的灵活映射**：在 [2090] 中，窗口长度为 `2k+1`，右端点 `i` 对应中心位置 `i - k`，实现“以右边界驱动中心计算”的变体逻辑；  
  - 熟悉**不同输出形式下的窗口处理策略**：  
    - [643] 输出最大平均值 → 维护最大和即可（避免重复除法）；  
    - [1343] 输出满足条件的子数组数量 → 判断 `sum >= threshold * k`；  
    - [2090] 输出每个中心的平均值 → 结果写入 `ans[i - k]`，边界由 `i ≥ 2k` 控制；  
  - 强化**数据类型与溢出意识**：使用 `long long` 存储窗口和，防止整数溢出影响正确性。  

- **卡点反思**：  
  - 初写 [2090] 时误将窗口长度当作 `k`，导致除数错误（应为 `2k+1`）及左端点移出位置偏差；  
  - 在 [643] 中曾忽略浮点精度要求，直接用 `int` 存储平均值，后修正为最后统一转 `double`；  
  - 对 [2090] 的“右边界即触发器”逻辑一度困惑：为何不显式维护左指针？后理解其本质仍是三步法，只是**窗口满的判定条件从 `i ≥ k-1` 变为 `i ≥ 2k`**，核心范式未变；  
  - 曾在窗口未满时提前执行“退出”操作，造成负下标访问或状态污染，再次印证“退出仅在窗口有效后发生”的铁律。  

- **收获与改进**：  
  - 确认**三步法具有高度泛化能力**：无论输出是极值、计数还是映射数组，只要问题涉及“固定长度连续子结构”，皆可套用此流程；  
  - 建立**窗口长度 ↔ 触发索引 ↔ 答案位置** 的三角对应关系：  
    - 长度 `L` → 首次有效右端点 `i = L - 1`；  
    - 若答案需关联中心，则中心 `c = i - (L - 1) / 2`（如 [2090] 中 `L=2k+1` ⇒ `c = i - k`）；  
  - 形成**防御性编码习惯**：  
    - 窗口和变量声明为 `long long`；  
    - “退出”操作严格置于“更新”之后，且包裹在 `if (i ≥ L - 1)` 条件内；  
    - 避免在循环早期对答案数组进行无效赋值；  
  - 意识到**变体非新范式，而是旧框架的新装束**：[2090] 表面特殊，实则仍是“右扩 → 满窗更新 → 左缩”的忠实实践者。
  - 已整理详细笔记：[《半径为k的子数组平均值》](https://github.com/Gelise436b/endless-cheng-leetcode/blob/main/sliding-window/%E5%8D%8A%E5%BE%84%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%B9%B3%E5%9D%87%E5%80%BC.md) 

- **明日计划**：  
  - 重做 [2090]，手写两遍，重点默写窗口长度 `2k+1` 与中心索引 `i - k` 的推导逻辑；  
  - 推进灵神题单滑动窗口模块：  
    - [2379] 得到 K 个黑块的最少涂色次数（定长窗口 + 条件计数）  
    - [2841] 几乎唯一子数组的最大和（定长窗口 + 极值更新）  
    - [2461] 长度为 K 子数组中的最大和（定长窗口 + 最大和模板巩固）  
  - 完善**滑动窗口问题识别 checklist**，新增条目：  
    - 若涉及“以某位置为中心”，是否可转化为固定长度窗口？  
    - 窗口长度是否隐含（如半径 `k` ⇒ 长度 `2k+1`）？  
    - 答案位置与当前右端点是否存在确定偏移？
      
### Day 3 - 滑动窗口进阶：条件判定与哈希协同  

- **完成题目**：  
  - [x] [2379] 得到 K 个黑块的最少涂色次数  
  - [x] [2841] 几乎唯一子数组的最大和  
  - [x] [2461] 长度为 K 子数组中的最大和  

- **学习重点**：  
  - **定长窗口 + 复杂条件判定**成为今日核心挑战：  
    - [2379] 转化为“长度为 K 的窗口中，最少将多少白块（'W'）改为黑块（'B'）”，等价于 **最小化窗口内 'W' 的数量**；  
    - [2461] 是经典模板题，巩固“固定长度窗口最大和”结构，强调 `long long` 防溢出与三步法节奏；  
    - [2841] 引入**元素多样性约束**（不同数字种类 ≥ m），需借助哈希表动态维护频次并利用 `map.size()` 判断合法性；  
  - **哈希表在滑动窗口中的精准维护**：  
    - 进入：`cnt[nums[i]]++`；  
    - 更新：仅当 `i ≥ k - 1` 且 `cnt.size() ≥ m` 时尝试更新答案；  
    - 退出：移除左端点元素后，若其计数归零，**必须执行 `erase`**，否则 `size()` 将包含无效键，导致条件误判；  
  - **问题转化能力提升**：  
    - [2379] 将字符串操作抽象为数值统计（'W' → 1，'B' → 0），转化为“定长子数组最小和”；  
    - [2841] 将“几乎唯一”语义转化为“不同元素种类数 ≥ m”，实现从自然语言到数学条件的映射；  
  - **统一框架下的策略分化**：  
    - 极值类（[2461], [2841]）→ 维护 `max_sum`；  
    - 最优操作类（[2379]）→ 维护 `min_count`；  
    - 条件满足类（[2841]）→ 引入辅助数据结构（map）进行状态验证。  

- **卡点反思**：  
  - 初解 [2841] 时，**未理解“几乎唯一”的准确含义**，误以为是“最多 m 种”或“恰好 m 种”，后通过题解明确为“至少 m 种不同元素”；  
  - 尝试用 `vector<int>` 或 `unordered_set` 实现去重，但无法处理重复元素的进出逻辑，**意识到频次统计不可省略**；  
  - 在滑窗退出阶段，**忘记对计数归零的键执行 `erase`**，导致 `map.size()` 虚高，使非法窗口被误判为合法，答案偏大；  
  - [2379] 中曾直接对字符操作，未转化为整型统计，代码冗余且易错，后改用预处理或在线判断 `s[i]=='W'` 简化逻辑；  
  - 对 [2461] 的边界处理稍显犹豫，担心 `k == nums.size()` 时左指针越界，实则三步法天然兼容全数组窗口。  

- **收获与改进**：  
  - **确认哈希表是处理“元素种类”类窗口问题的标准工具**，而 `size()` 的正确性依赖于**及时清理零频次键**；  
  - 建立 **“条件是否可增量维护”判断准则**：  
    - 若条件依赖集合大小、频次分布、唯一性等 → 引入 map/set；  
    - 若条件仅依赖和、最值、计数 → 无需额外结构；  
  - 强化 **“三步法 + 辅助结构”组合范式**：  
    ```cpp
    for (int i = 0; i < n; ++i) {
        // 1. 进入
        add(nums[i]);
        // 2. 更新（窗口满时）
        if (i >= k - 1) {
            if (valid()) ans = update(ans);
            // 3. 退出（为下一轮准备）
            remove(nums[i - k + 1]);
        }
    }
    ```  
  - 形成 **调试此类问题的 checklist**：  
    - map 是否在 `--cnt[x] == 0` 时 erase？  
    - 窗口满的判断是否为 `i >= k - 1`？  
    - 答案更新是否仅在窗口有效且条件满足时触发？  
  - 意识到 **“几乎唯一”是滑动窗口 + 哈希计数的经典交汇点**，未来遇到“多样性”“独特性”“种类数”等关键词，应立即联想此模式。
  - 已整理详细笔记：[《几乎唯一子数组的最大和》](https://github.com/Gelise436b/endless-cheng-leetcode/blob/main/sliding-window/%E5%87%A0%E4%B9%8E%E5%94%AF%E4%B8%80%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.md)  

- **明日计划**：  
  - 重做 [2841]，手写两遍，重点演练 `map` 的增删逻辑与 `size()` 的语义保障；  
  - 推进灵神题单滑动窗口模块：  
    - [1423] 可获得的最大点数（双端定长窗口 / 前缀和转化）  
    - [1176] 健身计划（变长窗口 + 二分 or 双指针，但先尝试定长思维迁移）  
    - [1100] 长度为 K 的无重复字符子串（定长 + 哈希去重，强化 `erase` 习惯）  
  - 完善**滑动窗口问题识别 checklist**，新增条目：  
    - 问题是否涉及“不同元素种类数”？ → 引入 map/set + erase 零频次；  
    - 条件是否可在 O(1) 内由辅助结构验证？ → 否则考虑其他算法；  
    - 窗口操作是否对称（如 [1423] 两端取）？ → 考虑补集思想或前缀和转化。
      
### Day 4 - 滑动窗口深化：逆向思维与边界转化  

- **完成题目**：  
  - [x] [1423] 可获得的最大点数  
  - [x] [1176] 健身计划  
  - [x] [1100] 长度为 K 的无重复字符子串  

- **学习重点**：  
  - **逆向思维在滑动窗口中的关键作用**：  
    - [1423] 本质是**从数组两端取共 k 张卡片**，看似无法用传统滑窗处理；但通过**补集思想**，将其转化为“在中间 n−k 个元素中找最小连续子数组和”，从而复用定长滑窗模板；  
    - 正向思路（枚举前 i 张 + 后 k−i 张）虽可行，但需维护前缀/后缀和，代码冗余且边界易错；而逆向解法仅需一次滑窗 + 总和减去最小窗口和，简洁高效；  
  - **C++ 标准库认知补全**：  
    - 初次接触 `std::reduce` 误以为是通用聚合函数，实则为 C++17 起支持的**并行求和函数**，等价于 `accumulate(..., 0)`；在 LeetCode 环境中更推荐使用 `accumulate` 以确保兼容性；  
  - **变长窗口与定长窗口的判别**：  
    - [1176] 表面是“连续 k 天”，实为**固定长度窗口评分问题**，与 Day 3 的健身计划题一致，强化了“窗口满时才评分”的条件触发逻辑；  
    - [1100] 是典型**定长 + 无重复约束**问题，需结合哈希表维护字符频次，并严格在移除左端点后 `erase` 零频次键，保障 `map.size() == k` 作为合法窗口判据；  
  - **统一解题范式再验证**：  
    - 极值类（[1423]）→ 总和 − 最小窗口和；  
    - 条件评分类（[1176]）→ 滑窗 + 分段判断；  
    - 唯一性约束类（[1100]）→ 定长滑窗 + 哈希去重 + erase 保障。  

- **卡点反思**：  
  - 面对 [1423] 时，**陷入“只能从两端取”的直觉陷阱**，未意识到剩余部分必为连续子数组，导致无法建立滑窗模型；  
  - 尝试正向枚举（前 i 后 k−i）时，因未预计算前缀/后缀和，导致每次求和 O(k)，整体复杂度退化至 O(k²)，效率低下；  
  - 对 `std::reduce` 的存在和语义不熟悉，在本地调试时报错，浪费时间排查环境问题，暴露了对 C++17 新特性的掌握不足；  
  - [1100] 中曾忽略“长度恰好为 K”这一硬性条件，误用变长窗口模板（如最长无重复子串），导致逻辑混乱；  
  - [1176] 的窗口起始位置判断稍显迟疑，担心 `i < k-1` 时提前评分，后确认“仅当 `i >= k-1` 才构成完整窗口”可安全规避。  

- **收获与改进**：  
  - **确立“补集转化”为滑动窗口高阶技巧**：当操作对象为“两端”或“非连续选取”时，优先思考“中间连续部分”的性质；  
  - **形成“定长窗口三要素”检查清单**：  
    - 窗口长度是否固定？ → 是 → 用 `i >= k-1` 触发更新；  
    - 是否需总和/最值？ → 用 `accumulate` 或滑窗和；  
    - 是否有唯一性/种类约束？ → 引入 map + erase 零频次；  
  - **强化标准库使用规范**：  
    - 在 LeetCode 或兼容性敏感场景，优先使用 `std::accumulate` 替代 `std::reduce`；  
    - 明确 `accumulate` 需显式传初始值（如 `0LL` 防溢出）；  
  - **建立“问题结构识别”反射**：  
    - “从两端取 k 个” → 补集 → 中间 n−k 连续 → 最小和；  
    - “连续 k 天评分” → 定长滑窗 + 条件分支；  
    - “长度为 K 且无重复” → 定长 + map.size() == K；  
  - 意识到**正向枚举并非总是最优**，有时逆向建模能将 O(k) 枚举降为 O(n) 单次滑窗。
  - 已整理详细笔记：[《可获得的最大点数》](https://github.com/Gelise436b/endless-cheng-leetcode/blob/main/sliding-window/%E5%8F%AF%E8%8E%B7%E5%BE%97%E7%9A%84%E6%9C%80%E5%A4%A7%E7%82%B9%E6%95%B0.md)  

- **明日计划**：  
  - **重做 [1423]**，手写两种解法（逆向滑窗 + 正向前缀/后缀和），对比代码简洁性与性能；  
  - 推进灵神题单滑动窗口模块：  
    - [1852] 每个子数组的数字和（定长滑窗 + 哈希计数，注意负数处理）  
    - [1151] 最少交换次数使数组元素相等（环形数组 + 滑窗，需转化问题）  
    - [2107] 含特定字符的子序列数目（非连续？需重新审题，可能非滑窗，先判断）  
  - 完善**滑动窗口适用性决策树**，新增分支：  
    - 操作对象是否为“两端”？ → 是 → 考虑补集转化为中间连续段；  
    - 是否必须恰好长度 K？ → 是 → 禁用变长窗口模板；  
    - 元素是否可重复？约束是否基于种类？ → 是 → map + erase 必备。
    - 
### Day 5 - 滑动窗口高阶应用：剩余集维护与问题建模再校准  

- **完成题目**：  
  - [x] [1852] 每个子数组的数字和  
  - [x] [1151] 最少交换次数使所有 1 聚合  
  - [x] [2107] 分享 K 个糖果后独特口味的数量  

- **学习重点**：  
  - **滑动窗口的核心对象决定解法方向**：  
    - [2107] 的关键突破在于**放弃对“被拿走窗口”的分析**，转而**直接维护“剩余 n−k 个元素”的哈希状态**；窗口滑动时，动态更新剩余集合的频次，其 `map.size()` 即为当前合法答案，避免了“窗口种类数 ≠ 被移除种类数”的经典误判；  
    - 对比 [1151]（求最小交换次数）：其本质是**固定长度窗口内 0 的最小数量**，因交换次数 = 窗口内非目标元素数，此时分析“被选中窗口”本身是合理的；而 [2107] 因涉及“全局频次完整性”，必须从剩余侧建模；  
  - **问题建模范式的精准匹配**：  
    - “最少交换使 1 聚合” → 定长滑窗 + 窗口内 0 的最小值；  
    - “分享 k 个后最大独特口味” → 定长滑窗 + **剩余部分种类数的最大值**；  
    - 二者虽同为定长滑窗，但**优化目标作用的对象截然不同**（前者关注窗口内部，后者关注窗口外部）；  
  - **哈希表维护的工程细节**：  
    - 在 [2107] 中，每次移除元素后需显式 `erase` 零频次键，否则 `map.size()` 会虚高；  
    - 初始化剩余集时，应从索引 `k` 开始填充，确保初始状态对应“拿走前 k 个”的场景；  
    - 滑动过程中，**加回左边界（i−1）、移出右边界（i+k−1）** 的操作顺序与窗口移动方向严格一致；  
  - **负数与溢出的鲁棒性处理**：  
    - [1852] 涉及子数组和的哈希计数，需注意前缀和可能为负，`unordered_map` 可天然支持；  
    - 累加时使用 `long long` 防止整型溢出，尤其在 LeetCode 极端测试用例下。  

- **卡点反思**：  
  - **[2107] 初期陷入严重建模误区**：试图通过“最小化被拿走窗口的种类数”来最大化剩余种类，忽略了“某口味是否被完全移除”取决于其**全局频次与窗口频次的相等性**，而非窗口是否包含该口味；  
  - 曾错误复用 [1151] 的思路，将 `ans = totalTypes - min_window_size` 作为答案，导致在 `[1,2,2,3,4,3], k=3` 等用例上输出 2（期望 3）；  
  - 调试时未及时打印中间状态，导致难以定位“窗口种类数”与“实际被移除种类数”的差异；  
  - [1852] 中一度混淆“子数组和”与“子序列和”，险些误入 DP 路线，后通过题干“连续子数组”关键词回归滑窗+前缀和正轨；  
  - [1151] 虽顺利 AC，但未深究其与环形数组变种（如 [LCR 010]）的联系，错失拓展机会。  

- **收获与改进**：  
  - **确立“剩余集维护”为一类独立滑窗范式**：当问题目标依赖于“未被选中部分”的性质（如种类、和、存在性）时，优先考虑直接建模剩余集合，而非通过补集间接推导；  
  - **形成“滑窗作用域”判断准则**：  
    - 若答案由**窗口内部属性**决定（如和、最值、0 的数量）→ 分析窗口本身；  
    - 若答案由**窗口外部属性**决定（如剩余种类、剩余和）→ 直接维护剩余集；  
  - **强化调试意识**：对逻辑复杂的滑窗题，主动添加 `cout` 打印 `map.size()`、关键变量值，快速验证中间状态；  
  - **明确 [2107] 的普适价值**：该题是“外部依赖型滑窗”的典型代表，可迁移至“删除一段后最大化剩余多样性”类问题（如字符串、数组去重场景）；  
  - 已整理详细笔记：[《分享k个糖果后独特口味的数量》](https://github.com/Gelise436b/endless-cheng-leetcode/blob/main/sliding-window/%E5%88%86%E4%BA%ABk%E4%B8%AA%E7%B3%96%E6%9E%9C%E5%90%8E%E7%8B%AC%E7%89%B9%E5%8F%A3%E5%91%B3%E7%9A%84%E6%95%B0%E9%87%8F.md)   

- **明日计划**：  
  - **深度复习 [2107]**：手写两种视角代码（错误的“窗口种类最小化” vs 正确的“剩余种类最大化”），对比逻辑差异与测试用例表现；  
  - 推进灵神题单滑动窗口模块：  
    - [3679] 满足条件的子序列数目（注意：题干若为“子序列”则非滑窗，需先确认是否为“子数组”；若是子数组，则可能为定长/变长滑窗 + 哈希/双指针）；  
    - [1052] 爱生气的书店老板（经典“翻转 k 个 0 使 1 最多”模型，转化为定长滑窗内 0 的最大数量）；  
    - [3439] 特定条件下子数组计数（预判为变长滑窗 + 哈希前缀和，需处理负数与模运算）；  
  - 完善**滑动窗口适用性决策树**，新增分支：  
    - 问题目标是否依赖“未被窗口覆盖的部分”？ → 是 → 采用剩余集维护策略；  
    - 是否涉及“全局频次完整性”判断？ → 是 → 必须记录 totalFreq 并对比 windowFreq（或直接维护剩余集）；  
    - 操作是否可逆且局部？ → 是 → 滑窗增删 O(1) 更新可行。
      
### Day 6 - 滑动窗口的语义建模与状态分离策略  

- **完成题目**：  
  - [x] [3679] 使库存平衡的最少丢弃次数  
  - [x] [1052] 爱生气的书店老板  
  - [x] [3439] 特定条件下子数组计数（空余时间段滑窗）  

- **学习重点**：  
  - **问题语义的精准解耦决定算法路径**：  
    - [3679] 的核心在于理解“丢弃”是**被动响应**而非主动过滤：只有当保留当前物品会导致**最近 `w` 天内该类型保留数量 > m** 时，才丢弃**这一次**；并非“一旦累计达 `m` 就永久拒绝”，更非“不入队”。正确模型应为**动态维护一个最多含 `w` 个元素的保留队列**，仅对保留项计数；  
    - [1052] 的关键突破是**将满意度拆解为两个独立部分**：  
      - **基础满意度**：所有 `grumpy[i] == 0` 的 `customers[i]` 之和（固定不变）；  
      - **可提升满意度**：在任意连续 `minutes` 窗口内，`grumpy[i] == 1` 的 `customers[i]` 之和（需最大化）；  
      - 最终答案 = 基础满意度 + 可提升满意度的最大值 → **无需二维数组，只需一维滑窗维护“生气时段的顾客和”**；  
    - [3439] 的洞察在于**将原始时间轴转化为“空余时间序列”**：若原问题描述为“在 `n` 天中安排 `k` 次移动，每次移动消耗 1 单位空闲时间”，则可预处理出每日空余时间数组 `idle[]`，问题转化为**在 `idle` 上求长度为 `k` 的子数组最大和** → 标准定长滑窗；  
  - **状态维护的边界一致性**：  
    - [3679] 中，窗口大小由**已保留物品数量**决定，而非原始天数；滑出操作仅在保留队列满 `w` 时触发；  
    - [1052] 中，滑窗长度严格等于 `minutes`，窗口滑动时需同步减去左边界（若当时生气）；  
    - [3439] 中，窗口长度等于“可执行操作次数”（如 `k` 次移动），需确保 `idle` 数组长度 ≥ `k`；  
  - **避免过度工程化**：  
    - [1052] 无需 `s[2]` 数组或二维结构，`s[0]` 可离线计算，`s[1]` 用单变量滑窗即可；  
    - [3679] 的“改值为 0” hack 虽可行，但**显式队列+计数器**更鲁棒，且逻辑自解释；  

- **卡点反思**：  
  - **[3679] 初期严重误读题意**：将“窗口内保留数量超限导致本次丢弃”误解为“全局达 `m` 后永久拒绝该类型”，导致错误地跳过后续同类型物品，未意识到**每个窗口独立判断、丢弃不影响未来**；  
  - **[1052] 陷入结构复杂化陷阱**：试图用二维数组分别记录生气/不生气的前缀和，忽略了“基础满意度可预计算、增量收益仅来自生气时段”的分离性，导致代码冗余且难以调试；  
  - **[3439] 完全未能建立问题映射**：困于原始时间轴描述，未想到将“可用资源”抽象为数组元素，错失滑窗建模机会；暴露了**从应用语境到数学模型的转化能力不足**；  
  - 三题均因**未先手写小规模模拟**而延长 debug 时间，尤其 [3679] 在 `w=1, m=1` 等边界用例上行为反直觉；  

- **收获与改进**：  
  - **确立“状态分离”为滑窗设计首要原则**：当问题包含**固定部分 + 可变部分**时（如 [1052] 的满意/可挽回顾客），优先拆解并独立处理；  
  - **强化“问题重述”能力**：面对复杂题干（如 [3439]），强制自己用一句话概括核心操作（例：“求 k 个连续空余时间的最大总和”），再匹配算法范式；  
  - **明确三类滑窗适用场景**：  
    - **内部属性优化**（[1151]）：窗口内 0 的最小数量；  
    - **外部属性优化**（[2107]）：剩余集合种类数最大；  
    - **混合状态分离**（[1052], [3679]）：固定收益 + 窗口内可变收益；  
  - **放弃“hack 式编码”**：[3679] 中改写输入数组虽简洁，但牺牲可读性与健壮性；今后优先采用**显式状态容器**（如 `queue<int> kept`）；  
  - 已更新笔记：[使库存平衡的最少丢弃次数](https://github.com/Gelise436b/endless-cheng-leetcode/blob/main/sliding-window/%E4%BD%BF%E5%BA%93%E5%AD%98%E5%B9%B3%E8%A1%A1%E7%9A%84%E6%9C%80%E5%B0%91%E4%B8%A2%E5%BC%83%E6%AC%A1%E6%95%B0.md),[爱生气的书店老板](https://github.com/Gelise436b/endless-cheng-leetcode/blob/main/sliding-window/%E7%88%B1%E7%94%9F%E6%B0%94%E7%9A%84%E4%B9%A6%E5%BA%97%E8%80%81%E6%9D%BF.md),[重新安排会议得到最多空余时间I](https://github.com/Gelise436b/endless-cheng-leetcode/blob/main/sliding-window/%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E4%BC%9A%E8%AE%AE%E5%BE%97%E5%88%B0%E6%9C%80%E5%A4%9A%E7%A9%BA%E4%BD%99%E6%97%B6%E9%97%B4I.md)

- **明日计划**：  
  - **深度复盘今日三题**：  
    - 手写 [3679] 两种实现（hack 版 vs 队列版），对比边界行为；  
    - 为 [1052] 绘制“基础满意度 + 滑窗增量”示意图，固化状态分离思维；  
    - 对 [3439] 进行问题重述训练：从题干提取“可滑动资源序列”；  
  - 推进灵神题单：  
    - [3694] 最多 K 次操作后的最大分数（预判为变长滑窗 + 哈希频次控制）；  
    - [3652] 恰好移动 k 步到达某位置的方法数（可能为 DP，需先确认是否含滑窗）；  
    - [2134] 最少侧跳次数（典型多状态滑窗/DP，分析车道切换的局部决策）；  
  - 完善**滑动窗口决策树**新增分支：  
    - 问题是否包含**不可变基础收益 + 可变窗口收益**？ → 是 → 分离计算；  
    - 操作对象是否为**派生序列**（如空余时间、差分数组）？ → 是 → 先转换再滑窗；  
    - 丢弃/保留决策是否**仅依赖当前窗口状态**？ → 是 → 用队列显式维护保留集。
   
### Day 7 - 回归基础与认知边界校准  

- **完成题目**：  
  - [x] [3694] 删除子字符串后不同的终点  
  - [x] [3652] 按策略买股票的最佳时机  

- **学习重点**：  
  - **状态建模能力仍待夯实**：  
    - [3694] 的核心障碍在于**未能将二维路径终点映射为可哈希的标量**。题解中通过 `(x + n) << 32 | (y + n)` 实现坐标压缩，本质是**利用偏移量消除负坐标、再通过位拼接构造唯一键**。此技巧依赖对内存布局和整数表示的理解，暴露了我在“状态编码”层面的经验缺失；  
    - [3652] 虽属经典股票 DP，但因题干引入**冷却期/交易次数/持有状态等复合约束**，导致无法快速抽象出状态转移方程。关键在于未识别出“**每天仅三种状态：空仓、持仓、冷却**”，陷入细节逻辑而忽略状态机主干；  
  - **难度感知与策略调整**：  
    - 1700+ 分题目普遍要求**多状态 DP 或高维滑窗**，而当前阶段应聚焦**单一算法范式的深度掌握**；  
    - 股票类 DP 虽标为 1700+，但其本质是**状态机模板的变体**，需先熟练掌握基础状态定义（如 `hold[i]`, `sold[i]`），而非直接挑战带复杂约束的版本；  

- **卡点反思**：  
  - **[3694] 陷入“模拟执念”**：试图用 BFS/DFS 枚举所有删除方案，未意识到终点仅由**总位移 - 被删段位移**决定，更未想到用数学编码替代 `pair<int,int>` 哈希；  
  - **[3652] 状态定义模糊**：  
    - 误将“是否在冷却期”作为独立维度，导致状态爆炸；  
    - 未抓住“**卖出后自动进入冷却，冷却一天后变为空仓**”的转移链条，错误地添加冗余状态；  
    - 忽略股票 DP 的通用套路：**以“是否持有股票”为核心状态，其他约束转化为转移条件**；  
  - **难度误判导致挫败感累积**：连续两题无法独立解决，根源在于**跳过基础巩固阶段直接挑战高维问题**，违背“由简入繁”的学习规律；  

- **收获与改进**：  
  - **确立“难度阈值”意识**：1700 分是当前能力分水岭，**暂停高分题攻坚，回归 1400–1700 分区间夯实基础**；  
  - **强化“问题降维”训练**：  
    - 遇到复杂题干时，强制执行三步：① 手写小规模示例；② 提取核心操作（如“删除子串→终点变化”）；③ 匹配基础模型（如“定长子数组→滑窗”）；  
    - 对 [3694] 的坐标编码技巧，补充笔记：**当需哈希多维状态且标准库不支持时，优先考虑位拼接（确保各维度值域 < 2³²）或线性组合（如 `x * BASE + y`）**；  
    - 对 [3652] 类股票题，建立状态机模板：  
      ```cpp
      hold[i] = max(hold[i-1], empty[i-1] - price[i]); // 继续持 or 买入
      sold[i] = hold[i-1] + price[i];                  // 卖出
      empty[i] = max(empty[i-1], sold[i-1]);           // 冷却结束 or 继续空仓
      ```  
  - **接受“暂时看不懂”**：高约束股票题暂标记为“DP 进阶待办”，待完成基础 DP 专题（如 [121]~[123]）后再回溯；  
  - 更新策略：**高分题仅用于拓展视野，不纳入当日核心任务**；  

- **明日计划**：  
  - **全面转向 1700 分以下题目**：  
    - 优先完成灵神题单中标记为 **“基础滑动窗口”** 的题目（如 [121] 买卖股票最佳时机、[209] 最小长度子数组）；  
    - 若题单中 1700 分以下题目耗尽，则启动 **“不定长滑动窗口” 专题**（如 [3] 无重复字符最长子串、[76] 最小覆盖子串）；  
  - **建立“基础题验收标准”**：  
    - 能 10 分钟内写出无 bug 代码；  
    - 能口述三种变体（如固定长/不定长/带权重）；  
    - 能手绘窗口扩张/收缩的指针移动过程；  
  - **补充工具链**：  
    - 整理常用状态编码模板（坐标压缩、多维状态 flatten）；  
    - 制作“滑动窗口决策速查表”：输入问题特征 → 输出窗口类型 + 维护状态；  
    - 归纳股票 DP 五部曲：状态定义 → 转移方程 → 初始化 → 遍历顺序 → 返回值。  

### Day 8 - 不定长滑动窗口的建模与逆向思维训练  

- **完成题目**：  
  - [x] [3] 无重复字符的最长子串  
  - [x] [3090] 每个子字符串最多包含两个不同字符  
  - [x] [1493] 删掉一个元素以后全为 1 的最长子数组  

- **学习重点**：  
  - **掌握“不定长滑动窗口”的核心范式**：  
    - 区别于固定长度窗口（如 [209]），**不定长窗口以“满足某条件的最大/最小子数组”为目标**，其关键在于**右指针扩张、左指针收缩的触发条件**；  
    - [3] 和 [3090] 共享同一模板：**维护字符频次哈希表 + 当种类数 > k 时收缩左边界**，体现了“**窗口合法性由内部状态决定**”这一原则；  
    - [1493] 则引入了**约束转化思想**：原问题“删掉一个 0 后全为 1 的最长子数组” ⇨ “**最多包含一个 0 的最长子数组**”，将“删除操作”转化为“容错计数”，是典型的**问题等价重构**；  
  - **逆向思维能力初显但未内化**：  
    - 在 [1493] 中，未能第一时间识别“删一个 0” ≡ “允许一个 0 存在”，反映出对“**操作语义 → 状态约束**”的映射不敏感；  
    - 此类转换在滑窗题中极为常见（如“最多 K 次替换” ⇨ “窗口内主元素频次 ≥ len−K”），需建立“**操作即容错”直觉**；  

- **卡点反思**：  
  - **[1493] 陷入正向模拟陷阱**：  
    - 初始思路试图枚举每个 0 的删除位置，再向左右扩展，导致 O(n²) 复杂度且边界处理复杂；  
    - 未意识到“**一次遍历 + 维护含 0 个数 ≤1 的窗口**”即可覆盖所有可能，本质是**将离散操作连续化**；  
  - **窗口收缩逻辑模糊**：  
    - 在 [3090] 中，曾错误地在每次右扩后立即收缩，而非“仅当不合法时才收缩”，导致窗口过早缩小、答案偏小；  
    - 根本原因是对“**while vs if**”的使用场景混淆：**非法状态需 while 循环持续收缩，合法状态只需 if 或无需处理**；  
  - **状态维护粒度粗糙**：  
    - 初写 [3] 时用 `set` 而非 `unordered_map<char, int>`，无法区分“字符存在但已移出窗口”的情况，导致 left 指针移动错误；  
    - 暴露了对“**频次精确统计 vs 存在性判断**”的适用边界不清——滑窗中几乎总是需要频次，而非布尔标记；  

- **收获与改进**：  
  - **提炼不定长滑窗通用模板**：  
    ```cpp
    int left = 0, max_len = 0;
    unordered_map<T, int> freq;
    for (int right = 0; right < n; ++right) {
        freq[arr[right]]++;               // 扩张右边界
        while (!valid(freq)) {            // 窗口非法时持续收缩
            freq[arr[left]]--;
            if (freq[arr[left]] == 0) freq.erase(arr[left]);
            left++;
        }
        max_len = max(max_len, right - left + 1); // 更新答案（合法窗口）
    }
    ```  
    - 关键函数 `valid(freq)` 需根据题意定制（如 `freq.size() <= 2` 或 `count_zero <= 1`）；  
  - **强化“约束转化”训练**：  
    - 遇到“删除/替换/跳过”等操作时，强制自问：“**能否转化为窗口内允许的异常数量？**”；  
    - 建立常见转化对照表：  
      | 原操作 | 等价窗口约束 |  
      |--------|----------------|  
      | 删除一个元素 | 最多含 1 个异类 |  
      | 替换 K 次 | 主元素频次 ≥ len − K |  
      | 跳过 M 个障碍 | 异常点 ≤ M |  
  - **明确数据结构选型原则**：  
    - 滑窗中若需判断“是否可收缩”，必须能**精确知道移除某元素后状态是否恢复合法** → 必须用**频次哈希表**，而非集合；  
  - **接受“模板需微调”**：  
    - [1493] 实际要求子数组**至少含一个 1**（全 0 不合法），但因输入保证有 1，故无需特判；未来需注意**边界合法性校验**；
    - [无重复字符的最长子串](https://github.com/Gelise436b/endless-cheng-leetcode/blob/main/sliding-window/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2.md),[删掉一个元素以后全为1的最长子数组](https://github.com/Gelise436b/endless-cheng-leetcode/blob/main/sliding-window/%E5%88%A0%E6%8E%89%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E4%BB%A5%E5%90%8E%E5%85%A8%E4%B8%BA1%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84.md)

- **明日计划**：  
  - **巩固今日三题**：  
    - 重写 [3090] 与 [1493]，确保 8 分钟内无 bug 完成；  
    - 手绘 [1493] 的窗口移动过程，标注 `left`、`right`、`zero_count` 变化；  
  - **推进新题（均 ≤1700 分）**：  
    - [3634] 字符串中最多包含 K 个不同字符的子串（不定长滑窗直接应用）；  
    - [1208] 尽可能使字符串相等的最小操作次数（转化为“子数组和 ≤ maxCost”的滑窗）；  
    - [904] 水果成篮（经典“最多两类”滑窗，与 [3090] 同源）；  
  - **构建“滑窗决策树”初稿**：  
    - 输入：问题描述关键词（如“最长”、“最多 K 种”、“替换”）；  
    - 输出：窗口类型（定长/不定长）、状态维护方式（频次/前缀和）、收缩条件；  
  - **坚持难度纪律**：所有新题严格控制在 1700 分以下，高分题仅作题解阅读。

### Day 9 - 不定长滑动窗口的深化与“问题本质识别”训练  

- **完成题目**：  
  - [x] [3634] 使数组平衡的最少移除数目  
  - [x] [1208] 尽可能使字符串相等的最小操作次数  
  - [x] [904] 水果成篮  

- **学习重点**：  
  - **巩固滑动窗口在非字符场景的迁移能力**：  
    - [904]（水果成篮）作为“最多两类元素”的经典模板题，与昨日 [3090] 形成呼应，实现零障碍复现；  
    - [1208] 成功将字符转换代价建模为**差值数组上的子数组和约束**（`sum ≤ maxCost`），验证了滑窗对“**连续区间资源限制**”问题的普适性；  
    - 两题均正确使用 `while` 循环收缩非法窗口，并在合法状态下更新最大长度，说明**窗口合法性驱动的扩张/收缩机制已初步固化**；  
  - **暴露“问题结构误判”风险**：  
    - [3634] 的核心并非滑动窗口，而是一个**贪心选择 + 排序优化**问题：目标是使数组中**所有元素相等**，求最少删除数 ⇨ 等价于**保留最多的相同元素**；  
    - 初始误以为需保持原数组顺序或考虑连续性，试图用滑窗维护“当前众数频次”，导致思路混乱；  
    - 关键顿悟：**删除操作不要求连续，且最终数组只需“全等”而非“有序”** → 因此最优策略必然是**保留出现次数最多的那个值的所有实例**，其余全部删除；  
    - 此错误反映出对“**操作自由度”与“目标状态约束**”的耦合分析不足——当删除无位置限制时，顺序信息即失效；  

- **卡点反思**：  
  - **[3634] 被“数组”二字误导，忽视组合本质**：  
    - 因近期密集训练“子数组”类滑窗题，看到“数组”+“移除”就潜意识绑定“连续区间”，忽略了本题的**全局选择属性**；  
    - 正确解法极其简洁：统计各元素频次 → 找最大频次 `maxFreq` → 答案为 `n - maxFreq`；  
    - 若题目要求“**连续子数组平衡**”，才需滑窗；但本题无此限制，故**排序与否不影响答案**（实际无需显式排序，仅需计数）；  
  - **编码细节仍存疏漏**：  
    - [1208] 中窗口长度计算误写为 `right - left`（漏 `+1`），因未在循环内打印调试信息而延迟发现；  
    - [904] 在收缩窗口时，对 `freq` 哈希表的清理逻辑冗余（未检查计数归零即 erase），虽功能正确但效率略低；  
    - 根源在于**写代码时未同步 mentally simulate 指针位置与窗口闭区间含义**；  

- **收获与改进**：  
  - **提炼“最少删除 ⇨ 最多保留”转化范式**：  
    - 当问题目标为“使数组满足某全局性质（如全等、和为偶、种类≤K）”且允许任意删除时，优先思考：  
      > “**保留哪些元素能最大化满足条件？**”  
    - 常见情形：  
      | 目标状态 | 最优保留策略 |  
      |----------|----------------|  
      | 所有元素相等 | 保留频次最高的元素 |  
      | 元素种类 ≤ K | 保留频次 Top-K 的元素 |  
      | 总和为偶数 | 保留总和 − 最小奇数（若总和奇）|  
    - 此类问题通常**无需滑动窗口**，而是**计数 + 贪心**；  
  - **强化“问题关键词”敏感度**：  
    - 见到“**最少删除/移除**”时，立即自问：  
      1. 删除是否要求连续？→ 否 ⇒ 考虑全局计数；  
      2. 目标状态是否依赖顺序？→ 否 ⇒ 可重排/无视索引；  
    - 与滑窗题的关键区分点：**滑窗处理“连续子数组”，贪心处理“任意子集”**；  
  - **完善编码 checklist**：  
    - 窗口长度：`right - left + 1`（闭区间）；  
    - 哈希表清理：`if (--freq[x] == 0) freq.erase(x)`；  
    - 边界测试：空输入、全同元素、极端 K 值；
    - [使数组平衡的最少移除数目](https://github.com/Gelise436b/endless-cheng-leetcode/blob/main/sliding-window/%E4%BD%BF%E6%95%B0%E7%BB%84%E5%B9%B3%E8%A1%A1%E7%9A%84%E6%9C%80%E5%B0%91%E7%A7%BB%E9%99%A4%E6%95%B0%E7%9B%AE.md)

- **明日计划**：  
  - **复习与纠偏**：  
    - 重做 [3634]，手写计数逻辑，明确其与滑窗问题的本质差异；  
    - 对比 [3634] 与 [1493]：前者删任意位置（子集），后者删一个后连续全1（子数组）→ 强化“连续性”判断；  
  - **推进新题（均 ≤1700 分）**：  
    - [1695] 删除子数组的最大得分（前缀和 + 滑窗/哈希优化）；  
    - [2958] 最多 K 个重复元素的最长子数组（不定长滑窗 + 频次约束）；  
    - [2024] 考试的最大困扰度（二分答案 + 滑窗验证）；  
  - **构建“滑窗 vs 贪心”决策分支**：  
    - 输入：问题是否强调“连续”、“子数组”、“相邻”？  
    - 输出：是 → 滑窗；否 → 考虑计数/排序/贪心；  
  - **坚持难度纪律**：新题严格 ≤1700 分，高分题仅阅读题解。
  
### Day 10 - 不定长滑动窗口的「频次-二分」双形态巩固  

- **完成题目**：  
  - [x] [1965] 最长连续子数组（频次差 ≤K）  
  - [x] [2958] 最多 K 个重复元素的最长子数组  
  - [ ] [2024] 考试的最大困扰度（未独立写出）  

- **学习重点**：  
  - **「频次差」滑窗模板固化**：  
    - [1965] 将「两个字母出现次数差」统一抽象为 `abs(cnt[c1]-cnt[c2])` 的**全局最大值**判定，窗口合法性条件转化为 `maxFreq - (right-left+1) ≤ k`；  
    - 成功复用「哈希表 + 最大频次变量」方案，避免二次遍历，实现 O(n) 单指针滑窗；  
    - 与 [2958] 对比：后者是「**单类元素频次上限**」，前者是「**两类元素频次差上限**」，二者共用「扩张-收缩」节奏，验证滑窗对「频次约束」问题的普适性；  
  - **二分答案 × 滑窗验证模式初体验**：  
    - [2024] 首次遇到「最小化最大连续更换次数」→ 天然满足**二分单调性**：  
      若「最大更换次数 ≤ mid」可达成，则更小 mid 也可达成；  
    - 独立写出 `check(mid)` 函数：用长度 = mid 的定长滑窗统计窗内最少需要改多少题（即 `min(改T数, 改F数)`），并发现「窗内最少更换次数」即为 `min(cntT, cntF)`；  
    - 但**未将 check 返回值与二分逻辑衔接**，导致最终代码缺 return，调试超时；  

- **卡点反思（2024 未写出根因）**：  
  1. **题型识别迟疑**  
     - 见到「最小化最大值」关键词未第一时间联想到二分答案，仍试图用不定长滑窗直接维护「最小更换」→ 发现窗口合法性难以定义，陷入死胡同；  
  2. **定长滑窗 → 二分框架断层**  
     - 虽正确实现 `check(mid)`，但在主函数里**忘记写二分外壳**（`while(low<=high)` 及中点更新），导致本地调试只跑了单次 check，无法输出最优解；  
  3. **变量命名与返回语义混淆**  
     - 把「当前窗口内最少更换次数」命名为 `change`，却误用 `ans` 接收，又在二分主函数里另起 `ans`，**内外层 ans 含义不一致**，编译通过但逻辑错位；  
  4. **边界样例未打印**  
     - 对 `k=0`、全同字符串场景未手动跑通，错失发现「二分初值 low 可设为 1」的契机；  

- **收获与改进**：  
  - **提炼「二分-滑窗」解题清单**：  
    1. 问题关键词：「最小化最大值 / 最大化最小值」→ 99% 二分答案；  
    2. 设计 `check(mid)`：  
       - 定长滑窗长度 = mid；  
       - 维护窗内「更换成本」或「违反次数」；  
       - 一旦找到满足条件的窗口即返回 true；  
    3. 二分外壳模板：  
    ```cpp
    int low = 1, high = n, ans = n;
    while (low <= high) {
        int mid = (low + high) / 2;
        if (check(mid)) { ans = mid; high = mid - 1; }
        else low = mid + 1;
    }
    ```  
  - **强化「频次-差值」两类约束的对比记忆**：  
    | 场景 | 合法性条件 | 关键变量 |  
    |---|---|---|  
    | 单类频次 ≤ K | `freq[x] <= k` | 哈希表 + 计数 |  
    | 两类频次差 ≤ K | `maxFreq - windowLen <= k` | 全局 maxFreq |  
  - **编码纪律**：  
    - 二分答案题先写外壳再填 `check`；  
    - `check` 函数内部禁用外部同名变量，杜绝 shadowing；  
    - 提交前必跑三组极小样例并打印中间值；
    - [考试的最大困扰度](https://github.com/Gelise436b/endless-cheng-leetcode/blob/main/sliding-window/%E8%80%83%E8%AF%95%E7%9A%84%E6%9C%80%E5%A4%A7%E5%9B%B0%E6%89%B0%E5%BA%A6.md)

- **明日计划（Day 11）**：  
  - **重做 [2024]**：手写完整二分-定长滑窗模板，确保 5 分钟内一次过；  
  - **新题（均 ≤1700）**：  
    - [1004] 最大连续 1 的个数 III（不定长滑窗，翻转次数 ≤ K）；  
    - [1658] 将 x 减到 0 的最小操作数（前缀和 + 滑窗转「中间段」问题）；  
    - [3641] 特殊数组 I（定长滑窗验证连续奇偶段）；  
  - **构建「二分-滑窗」题库**：把 [2024][1547][2064] 等归入同一思维导图，标注 `check()` 实现差异；  
  - **坚持难度纪律**：新题分值 ≤1700，>1700 仅阅读题解不编码。

### Day 11 - 逆向思维转化与状态维护的精准性
* **完成题目**：
* [x] **[1004] 最大连续 1 的个数 III**（不定长滑窗，转化思路：最多允许 K 个 0）
* [x] **[1658] 将 x 减到 0 的最小操作数**（逆向思维：两头减  中间留最长）
* [x] **[3641/2730] 最长半重复子数组**（状态机滑窗，修正 erase 误用）

* **学习重点**：
* **逆向思维模型建立 ([1658])**：
* 物理动作是“从两端移除元素”，逻辑动作应转化为“保留总和为 `sum(nums) - x` 的最长连续子数组”；
* **公式化**：`Target = TotalSum - x`。若 `Target < 0` 直接返回 -1；否则问题退化为标准的“和为 Target 的最长子数组”；

* **窗口状态的原子操作 ([3641])**：
* 深刻理解了 `cnt[x]--` 与 `cnt.erase(x)` 的区别：滑动窗口是“移出视野”，不是“毁灭数据”。
* 明确了“半重复”的计数逻辑：不是统计总重复次数，而是统计有多少个**数值**的频次 `>1`。

* **C++ 工程规范初探**：
* 遭遇 `std::reduce` 版本兼容性问题（C++17 特性），确立了刷题首选 `std::accumulate`（C++98 兼容）的原则；
* 明确求和防溢出写法：`accumulate(..., 0LL)`。
  
* **卡点反思**：
* **思维转化的“阻尼感” ([1658])**：
* **现象**：读题后执着于模拟“左边拿一个、右边拿一个”的过程，无法建立“剩余部分”的连续性视角。
* **根因**：大脑习惯正向模拟（Imperative），不习惯声明式（Declarative）的目标转化。**未画图辅助**，导致没看出来“剩下的部分”一定是连续的。

* **状态维护的“暴力倾向” ([3641])**：
* **现象**：面对窗口收缩，粗暴使用 `INT_MIN` 标记重复，使用 `erase` 清除 key。
* **根因**：对 Map 的底层操作含义理解不深。在滑动窗口中，Key 的 value 代表“窗内存在个数”，是渐变过程（2->1->0），不能直接用 `erase` 制造断崖式突变。

* **环境配置陷阱**：
* 在 VS Code 中耗费时间解决 `reduce` 报错，意识到工程环境（C++ Standard）与代码实现的解耦重要性。

* **收获与改进**：
* **建立“逆向转化”检查单**：
* 遇到关键词“从边缘移除”、“前缀+后缀满足条件”  **立即思考：中间剩下了什么？**
* 遇到“最少操作次数（移除）”  **转化为：最长子数组长度（保留）**。

* **滑窗状态维护三戒**：
1. 戒 `erase`：除非确定该元素永远不再进入逻辑判断。
2. 戒 `Magic Number`：不要用 `INT_MIN` 代替具体的计数逻辑。
3. 戒“想当然的减法”：只有当 `cnt` 从 2 变为 1 的**瞬间**，`sum`（重复数种类）才能减 1。

* **技术债补全**：
* 以后求和统一用 `<numeric>` 库的 `accumulate`，起手式写 `long long total = accumulate(nums.begin(), nums.end(), 0LL);`。

* **明日计划（Day 12）**：
* **复习巩固**：
* 重写 [1658]：不看题解，画图确认 `Total - x` 逻辑，5分钟 AC。
* 重写 [3641]：使用规范的 `map` 计数逻辑，严控 `sum` 的增减时机。
  
* **新题攻坚**：
* [2730] 最长半重复子数组（确认是否为 3641 同款，若是则作为复习）。
* [2779] 数组的最大美丽值（排序 + 滑动窗口，找值域覆盖）。
* [1838] 最高频元素的频数（经典的“补齐”代价计算，滑窗 + 前缀和/数学逻辑）。

### Day 12 - 逆向补集思维与宏观数学视野

* **完成题目**：
* [x] **[76] 最小覆盖子串**（经典题：从暴力对比  进化到单变量维护 ）
* [x] **[1234] 替换子串得到平衡字符串**（逆向思维：不可变区域 vs 可变区域）
* [x] **[2875] 无限数组的最短子数组**（数学 + 滑窗：大数靠除法，小数靠取模）


* **学习重点**：
* **记账法的抽象化 ([76])**：
* 放弃直观的“两个 Map 对比”，转为“差分记账”。
* **正数=欠债，0=收支平衡，负数=盈余**。
* 引入 `less` 变量作为“欠债种类计数器”，将  的状态检查降维为  的变量判断。


* **逆向补集思维 ([1234])**：
* 问题看似在问“怎么修改子串”，实则约束在“**子串之外（不可变区域）**必须满足什么”。
* **判据转化**：只要外部区域所有字符数量 ，内部（可变区域）一定能通过修改来补齐缺口。


* **无限/环形数组的处理范式 ([2875])**：
* **宏观（Math）**：`Target` 极大时，利用整数除法 `k = target / totalSum` 剥离出完整的周期，贡献长度 `k * n`。
* **微观（Algo）**：剩余的 `remainder = target % totalSum` 在 `2*n` 长度内解决。
* **技巧**：不进行物理拷贝，使用下标取模 `nums[i % n]` 模拟环形。




* **卡点反思**：
* **思维惯性的“模拟陷阱” ([76])**：
* **现象**：第一版代码写了 `is_covered` 函数，每次移动指针都循环 52 次检查 A-Za-z。
* **根因**：思维停留在“模拟人类检查作业”的层面（逐项核对），未上升到“状态机/计数器”层面（只关注变化的瞬间）。**未意识到 `cnt` 从 1 变 0 是唯一的“质变”时刻。**


* **被“无限”二字吓退 ([2875])**：
* **现象**：试图开辟 `target * n` 的巨型数组，或者仅在 `2*n` 范围内搜索导致漏掉大数解；写出了 `min(left, len)` 这种逻辑笔误。
* **根因**：缺乏“分治”思想，试图用一种手段（滑窗）解决所有规模的问题。忽略了算法的时间复杂度限制，以及 `left` 是坐标、`len` 是长度的物理意义区别。


* **可变与不可变的混淆 ([1234])**：
* **现象**：一直纠结“如果我把子串改了，怎么保证整体平衡”，试图去凑子串里的字。
* **根因**：没有划清界限。**子串内是自由的（Wildcard）**，不需要操心；**子串外是刚性的**，才是制约条件的来源。进窗操作本质上是将元素从“刚性区”移入“自由区”（所以是 `cnt--`）。




* **C++ 工程规范积累**：
* **溢出防御**：涉及累加求和（尤其是 `target` 很大时），必须使用 `long long`。
* **取模技巧**：`index % n` 是处理环形数组的标准动作，优于 `array.insert`。


* **收获与改进**：
* **建立“状态降维”检查单**：
* 如果发现自己在滑窗内写了 `for` 循环检查状态  **立即警觉**，一定可以用变量维护（`less`, `count`, `mask` 等）。


* **建立“大数拆解”模型**：
* 遇到“无限重复”、“周期性”且 Target 巨大的题目  **公式：`Total = (Div * N) + Mod_Solver**`。


* **滑窗逻辑修正**：
* `min` 函数的参数永远是 `(ans, new_len)`，绝不可能是 `(left, ...)`。
* `cnt` 数组的含义要明确：是“窗口内的统计”还是“窗口外的统计（补集）”？（1234题为后者）。
* [无限数组的最短子数组](https://github.com/Gelise436b/endless-cheng-leetcode/blob/main/sliding-window/%E6%97%A0%E9%99%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84.md),[最小覆盖子串](https://github.com/Gelise436b/endless-cheng-leetcode/blob/main/sliding-window/%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2.md),[替换子串得到平衡子串](https://github.com/Gelise436b/endless-cheng-leetcode/blob/main/sliding-window/%E6%9B%BF%E6%8D%A2%E5%AD%90%E4%B8%B2%E5%BE%97%E5%88%B0%E5%B9%B3%E8%A1%A1%E4%B8%B2.md)





* **明日计划（Day 13）**：
* **复习巩固**：
* 重写 [2875]：重点练习 `k` 的计算逻辑和取模滑窗的结合，确保 `long long` 不溢出。
* 脑内演练 [76]：回忆 `less` 变量在 `cnt` 变 0 时的增减逻辑。


* **新题攻坚（进入灵神“越短越合法”部分）**：
* **[632] 最小区间**（Hard）：多个有序列表的滑窗，涉及堆（Priority Queue）与滑窗的结合，可能是 [76] 的多维变体。
* **[713] 乘积小于 K 的子数组**：经典的“越短越合法”  “越长越不合法”，注意计数逻辑 `ans += right - left + 1`。
* **[3258] 统计满足 K 约束的子字符串数量 I**：数据范围小，重点练习滑窗逻辑的通解性。

### Day 13 - 滑窗内的“计数原理”与逻辑修正

* **完成题目**：
* [x] **[713] 乘积小于 K 的子数组**（核心：滑窗计数公式的纠正 `ans++` vs `+= len`）
* [x] **[3258] 统计满足 K 约束的子字符串数量 I**（纠错：索引越界保护与逻辑反转 `||` vs `&&`）
* [x] **[2302] 统计得分小于 K 的子数组数目**（进阶：数据类型溢出与题目公式的准确映射）


* **学习重点**：
* **滑窗计数的通用公式 ([713])**：
* **误区**：`ans++`。认为每次右移只新增了一个“最长”的合法子串。
* **正解**：`ans += right - left + 1`。
* **原理**：一个合法窗口 `[left, right]` 内部，以 `nums[right]` **结尾**的合法子数组数量，严格等于当前窗口的长度。这是**不重不漏**统计的关键。


* **双重约束的逻辑反转 ([3258])**：
* **题目要求**：`Count0 <= k` **OR** `Count1 <= k` 为合法。
* **滑窗收缩条件（不合法）**：利用德摩根定律，收缩条件应为 `Count0 > k` **AND** `Count1 > k`。只有当两个都爆了，才需要移动左指针。


* **分数定义的物理意义 ([2302])**：
* 题目定义的“分数”是 `sum * length`。不能惯性地写成 `sum * n`（总长度），必须是动态的 `sum * (right - left + 1)`。




* **卡点反思**：
* **计数逻辑的惯性思维 ([713], [3258])**：
* **现象**：连续两道题起手都写了 `ans++`。
* **根因**：潜意识里把滑动窗口看作一个“静态对象”，忽略了窗口扩张时带来的**组合爆炸**效应。
* **对策**：遇到“统计子数组数量”的题目，**肌肉记忆**直接映射到 `right - left + 1`。


* **索引与值的混淆 ([3258])**：
* **现象**：写出了 `cnt[left]--` 导致数组越界或逻辑崩溃。
* **根因**：混淆了 **指针（Iterator/Index）** 与 **数据（Value）**。`left` 只是游标，`s[left]` 才是字符。
* **对策**：在写 `cnt` 更新时，强制自己读作“计数数组减去**字符串中左指针指向的字符**”。


* **数据类型的轻视 ([2302])**：
* **现象**：`ans` 和 `sum` 使用 `int`，且试图用 `count` 变量额外维护长度。
* **根因**：未对  规模的数据产生“溢出警觉”；未意识到 `right-left+1` 本身就是最准确的长度，引入额外变量反而增加了维护成本。




* **C++ 工程规范积累**：
* **溢出防御**：涉及“子数组数量累加”、“元素和乘积”时，**无脑上 `long long**`。
* **特判防御**：在 [713] 中，如果 `k <= 1` 且数组元素均为正整数，直接返回 0，避免 `while` 循环中的除零或逻辑错误。
* **代码洁癖**：`while` 循环保证了出窗后的合法性，因此不需要在 `while` 后再加 `if` 判断（除非是处理空窗情况，但计数公式能自然处理长度为0的情况）。


* **收获与改进**：
* **建立了“计数滑窗”的标准模板**：
```cpp
for (right...) {
    In(); // 入窗更新
    while (不合法条件) {
        Out(); // 出窗更新
        left++;
    }
    ans += (right - left + 1); // 核心计数逻辑
}

```


* **逻辑检查单更新**：
* [ ] 题目是求“最大长度”还是“子数组个数”？如果是个数，用 `+= len`。
* [ ] 收缩条件写对了吗？是“或”还是“且”？
* [ ] `cnt` 的下标是 `left` 还是 `s[left]`？
* [ ] 数据会不会爆 `int`？





---

* **明日计划（Day 14）**：
* **复习巩固**：
* 重写 [713] 和 [3258]：必须像呼吸一样自然地写出 `ans += right - left + 1`。


* **新题攻坚（计数滑窗进阶：复杂状态维护）**：
* **[2743] 计算没有重复字符的子字符串数量**：
* *预习视角*：这是计数滑窗的最基础形态。不合法条件是 `cnt[x] > 1`。这道题是下面两道题的基石。


* **[LCP 68] 美观的花束**：
* *预习视角*：[2743] 的升级版。从“不能有重复（cnt > 1）”变成了“不能超过 k 个（cnt > k）”。需要熟练掌握哈希表或数组计数。


* **[2762] 连续子数组**：
* *预习视角*：**重难点**。这道题的“不合法条件”变难了——需要维护窗口内的**最大值和最小值之差**。
* *思考*：怎么高效知道窗口里的 Max 和 Min？（可能需要 `std::map`，`std::multiset` 或者双单调队列）。不要被吓到，外层的 `ans += len` 逻辑是不变的！
* 

### Day 14 - 滑窗计数进阶与逻辑陷阱修复

* **完成题目**：
* [x] **[2743] 计算没有重复字符的子字符串数量**（基础计数：修复了死循环漏写 `left++` 与 API 误用）
* [x] **[LCP 68] 美观的花束**（进阶计数：纠正了“视错觉”语法 `cnt[x>k]` 与 `long long` 溢出）
* [x] **[2762] 不间断子数组**（有序容器应用：引入 `std::map` 自动维护窗口内的 Max/Min 差值）


* **学习重点**：
* **“无辜者”的牺牲逻辑 ([LCP 68])**：
* **疑问**：为什么 `nums[right]` 超标了，却要移除可能不相关的 `nums[left]`？
* **顿悟**：为了维护子数组的**连续性**。要剔除窗口里那个**旧的**导致冲突的元素，必须先把它左边的所有“无辜”元素都移出窗口。这些被移出的元素在之前的轮次中已经贡献了 `ans`，此时它们的历史使命已完成。


* **有序容器在滑窗中的威力 ([2762])**：
* 当约束条件涉及“最大值/最小值”时，普通的计数数组失效。
* **`std::map` 的妙用**：利用红黑树的自动排序特性，`begin()` 是最小值，`rbegin()` 是最大值。极差判断化简为 `map.rbegin()->first - map.begin()->first <= 2`。


* **历史贡献的不可逆性**：
* 再次确认 `ans += right - left + 1` 的物理含义：被 `left++` 抛弃的元素，在它们还在窗口内时，已经作为合法子数组的“一部分”被统计过了（落袋为安）。




* **卡点反思**：
* **致命的“视错觉”语法 ([LCP 68])**：
* **现象**：写出了 `while(cnt[flowers[right]>cnt])`。
* **后果**：把布尔判断 `True/False` 当作了数组下标，导致逻辑完全错乱且编译器不报错。
* **对策**：写复杂下标判断时，**先写下标，再写比较运算符**。心中默念“取值再比较”。


* **机械性死循环 ([2743])**：
* **现象**：在 `while` 循环里写了 `cnt[left]--`，却唯独**忘了写 `left++**`。
* **后果**：指针原地踏步，计数器减成负无穷，程序卡死。
* **对策**：写 `while` 缩窗逻辑时，先把 `left++` 写上，再补里面的业务逻辑。


* **API 误用 ([2743])**：
* **现象**：`erase(cnt[s[left]])` 试图删除“计数”，而非删除“字符 Key”。
* **纠正**：`map.erase(key)` 才是删除键值对。




* **C++ 工程规范积累**：
* **数据规模敏感度**：看到  的数据量求“子数组数量”，**必须**使用 `long long`，不要抱有侥幸心理。
* **取模规范**：涉及大数累加时，注意题目是否要求 `% 1e9+7`。
* **容器选择**：
* 求极值/有序  `std::map` / `std::set`。
* 纯字符计数  `vector<int>(26)` 或 `array`（比 map 快得多）。




* **收获与改进**：
* **建立了“Map 滑窗”模板**：
```cpp
map<int, int> window;
for (right...) {
    window[nums[right]]++; // 进窗
    while (window.rbegin()->first - window.begin()->first > LIMIT) { // 检查极值
        window[nums[left]]--; // 出窗
        if (window[nums[left]] == 0) window.erase(nums[left]); // 必须彻底删除 Key，否则影响 begin/rbegin
        left++;
    }
    ans += ...
}

```


* **逻辑检查单新增**：
* [ ] `while` 循环里写 `left++` 了吗？
* [ ] `cnt` 数组的下标括对了吗？
* [ ] `erase` 删的是 Key 还是 Value？





---

* **明日计划（Day 15）**：
* **复习巩固**：
* 手写一遍 [2762]：强化 `map` 的 `erase` 逻辑（计数为 0 时必须删 Key）。
* 检查 [LCP 68]：确保不再犯括号位置错误。


* **新题攻坚（越长越合法 / 至少 K 个）**：
* *预习视角*：之前的题目是“不能超过 K（越短越容易合法）”，接下来的题目是“至少需要 K（越长越容易合法）”。
* **[1358] 包含所有三种字符的子字符串数目**：
* *思考*：当窗口包含了 a,b,c 时，继续往右扩肯定也包含。这时候怎么计算？是加左边的空间吗？


* **[2962] 统计最大元素出现至少 K 次的子数组**：
* *思考*：如果不满足 K 次，需要右扩；一旦满足 K 次，左边怎么收缩？


* **[3325] 字符至少出现 K 次的子字符串 I**：
* *思考*：巩固“至少”的滑窗逻辑，注意与“至多”逻辑的区别（可能是 `ans += left` 而不是 `right-left+1`）。

### Day 15 - 逆向思维：从“至多”跨越到“至少”

* **完成题目**：
* [x] **[1358] 包含所有三种字符的子字符串数目**（基础入门：第一次遭遇 `ans += left` 逻辑，修复了 `char` 直接作下标的越界错误）
* [x] **[2962] 统计最大元素出现至少 K 次的子数组**（进阶应用：从 `map` 优化为 `int` 计数，解决了 `int` 溢出问题）
* [x] **[3325] 字符至少出现 K 次的子字符串 I**（特殊解法：验证了 `while(cnt==k)` 这种“过河拆桥”式贪心的有效性）


* **学习重点**：
* **逻辑大翻转：“至多” vs “至少”**
* **至多 K 个**（昨天的逻辑）：窗口**越短**越安全。`while` 循环是为了**踢人**让窗口变合法。计算公式是 `right - left + 1`（当前合法的长度）。
* **至少 K 个**（今天的逻辑）：窗口**越长**越安全。`while` 循环是为了**尝试收缩**看能不能更短。


* **计数公式的物理含义 (`ans += left`)**：
* 当窗口 `[left, right]` 刚刚满足条件（或者刚变得不满足时，取决于具体写法），`left` 指针的位置代表了 **“有多少个合法的左边界”**。
* 既然 `[left-1, right]` 已经满足了“至少”的要求，那么 `[0...left-1]` 作为起点肯定都满足（因为只会包含更多字符）。所以直接把这 `left` 个起点全加进去。




* **卡点反思**：
* **数组下标的隐形杀手 ([1358])**：
* **现象**：`cnt[s[right]]` 直接崩掉。
* **原因**：`char` 'a' 的 ASCII 是 97，定义的 `int cnt[3]` 只有 3 个位置。
* **对策**：涉及字符映射数组时，必须养成肌肉记忆写 **`- 'a'`** 或 **`- '0'`**。


* **隐蔽的整数溢出 ([2962], [3325])**：
* **现象**：题目通过了但结果不对，或者在大数据下报错。
* **原因**：子数组计数通常是  级别的，`10^5` 的数据量会轻松突破 `int` (20亿) 上限。
* **对策**：看到“统计...子数组数量/数目”，**无脑声明 `long long ans = 0**`。


* **杀鸡焉用牛刀 ([2962])**：
* **现象**：只统计“最大值”这一个数字，却用了 `map<int, int>`。
* **后果**：性能由  劣化为 。
* **对策**：如果只需要关注**特定**元素的计数，直接用 `int cnt` 变量或 `if (x == target)` 即可，不要滥用 `map`。




* **C++ 工程规范积累**：
* **API 使用**：查找 vector 最大值用 `*max_element(v.begin(), v.end())`。
* **布尔值技巧**：`cnt += (x == mx)`。利用 `true=1, false=0` 的特性，可以把 `if` 语句写得极简（虽然可读性见仁见智，但要能看懂别人的这种写法）。
* **特解与通解**：
* 在 [3325] 中，我使用的 `while(cnt == k)` 是一种**特解**。它利用了“每次只加1”的特性，强制把 `k+1` 的状态扼杀在摇篮里。虽然 AC 了，但要注意这种写法的脆弱性（如果一次加入多个字符就会崩）。




* **收获与改进**：
* **建立了“至少 K 个”滑窗模板**：



```cpp
long long ans = 0; // 必须 long long
int left = 0;
// 状态变量 (比如 cnt, map, 或者 satisfy_count)

for (right...) {
    // 1. 进窗更新状态
    update(nums[right]);
    
    // 2. 只要满足“至少”的条件，就尝试收缩
    // (在我的 [3325] 特解中，这里是 while(cnt == k))
    while (check_valid()) {
        remove(nums[left]);
        left++;
    }
    
    // 3. 核心差异点：累加合法的左起点数量
    // 此时 [0...left-1] 到 right 都是合法的
    ans += left; 
}
return ans;

```

* **逻辑检查单新增**：
* [ ] 题目求“数量”吗？是的话 `ans` 改成 `long long` 了吗？
* [ ] 数组下标越界了吗？字符有没有 `- 'a'`？
* [ ] 只统计一个数吗？是的话把 `map` 删了换 `int` 变量。



---

* **明日计划（Day 16）**：
* **复习巩固**：
* 重新审视 [3325] 的“标准解法”（`satisfy` 变量法）和我的“贪心解法”的区别，确保理解两种思路。


* **新题攻坚（混合逻辑 / 复杂判断）**：
* **[2799] 统计完全子数组的数目**：
* *思考*：这也是一个“至少”问题（至少包含所有不同元素），逻辑应该和今天的一样。


* **[2537] 统计好子数组的数目**：
* *思考*：“好”的定义涉及“对数”，这需要数学组合数还是直接滑窗？应该也是 `ans += left` 模型。


* **[3298] 统计重新排列后包含另一个字符串的子字符串数目 I**：
* *思考*：这题听起来像是 [1358] 的升级版，不仅要包含，还要看数量（字符频次），估计要上 `vector<int>(26)` 计数对比了。

---
### Day 16 - 组合数学与状态压缩：破解“复杂条件”滑窗

* **完成题目**：
* [x] **[2799] 统计完全子数组的数目**（热身：逻辑同昨天的“至少 K 个”，只是 K 变成了 `set.size()`）
* [x] **[2537] 统计好子数组的数目**（思维突破：从“计数”跨越到“组合数”，掌握了 `pairs += cnt[x]` 的握手定理）
* [x] **[3298] 统计重新排列后包含另一个字符串的子字符串数目 II**（难点攻克：学会了用 `diff` 数组 + `less` 变量把 O(26) 的检查压缩为 O(1)）


* **学习重点**：
* **组合数学进滑窗 ([2537])**
* **误区**：开始时以为是统计某个数出现 K 次。
* **正解**：题目求的是 **配对数 (Pairs)**。
* **握手定理**：新加入一个数 `x`，如果窗口里已经有 `c` 个 `x`，那么新增的配对数就是 `c`。不需要重新算 。
* **公式**：`pairs += cnt[x]` （进窗前）；`pairs -= (cnt[x]-1)` （出窗后）。


* **题目“黑话”翻译 ([3298])**
* **黑话**：“重排后包含 word2 是前缀”。
* **人话**：**“查库存”**。只要子数组里每个字符的数量  word2 里要求的数量即可。跟排列顺序无关。


* **状态压缩技巧 (State Compression)**
* **笨办法**：每次循环都遍历 `vector<int>` 检查 26 个字母够不够。
* **聪明办法 (`less` 变量)**：
* 只维护一个 `less` 变量，代表 **“还有几种字符没凑齐”**。
* 当 `less == 0` 时，直接判断窗口合法。
* 这样把检查的时间复杂度从  降到了 。






* **代码逻辑深度解析 ([3298] 参考解法)**：
* 这题的代码逻辑非常精妙，值得背诵。
* **初始化**：`diff` 数组存“欠债”（正数表示还缺多少）。`less` 存“有几类字符是欠债状态”。
* **进窗口 (`right`)**：
* `diff[in]--`：无论是不是欠债，先还一个。
* `if (diff[in] == 0) less--`：如果你原本欠债（正数），减完变成 0 了，说明这笔债还清了，欠债种类 `less` 减 1。


* **出窗口 (`left`)**：
* `if (diff[out] == 0) less++`：如果你原本正好还清（0），现在要拿走一个，那就变成欠债了，`less` 加 1。
* `diff[out]++`：把拿走的债记回去。


* **判断**：`while (less == 0)` 表示所有债务都还清了，窗口合法，尝试收缩。


* **卡点反思**：
* **数学直觉缺失 ([2537])**：
* **现象**：纠结于 `cnt[x] == k`。
* **对策**：看到“**对 (Pair)**”、“**组合**”字眼，立刻反应过来是  模型，而不是简单的计数模型。


* **被题目描述吓退 ([3298])**：
* **现象**：看到“重排”、“前缀”觉得很难。
* **对策**：所有涉及“子串重排”的题目，本质都是 **哈希表/数组计数 (Frequency Count)**。不要去想排序。


* **API 与初始化**：
* `int diff[26]{}`：这种写法在 C++ 中可以把数组初始化为全 0，很方便。




* **收获与改进**：
* **通用模板升级**：现在可以处理更复杂的 `check()` 逻辑了。
* **O(1) Check 思想**：以后遇到需要检查多个条件（比如 26 个字母、3 种类型等）的情况，不要每次都遍历，而是维护一个 `count` 变量来记录“满足条件的个数”。


* **明日计划（Day 17）**：
* **复习巩固**：
* 重点重写一遍 **[2537]**（熟悉配对逻辑）和 **[3298]**（熟悉 `less` 变量的维护逻辑），确保不看答案能写出 `diff` 的加减细节。


* **新题攻坚（二元子数组 / 前缀和思想）**：
* **[2495] 统计偶数子数组的数目**（考察对奇偶性的敏感度）
* **[930] 和相同的二元子数组**（经典的“恰好 K 个”，可能需要转换为“至多 K - 至多 K-1”或者用前缀和哈希表）
* **[1248] 统计「优美子数组」**（[930] 的变体，把奇数看作 1，偶数看作 0）
