# LeetCode 灵神题单精研笔记  
> **从范式启航，向思维深处漫溯**  

---

## 📅 学习日志  
## 📚 目录

- [📅 Day 1 - 滑动窗口启航：定长窗口的元音之眼](#day-1---滑动窗口启航定长窗口的元音之眼)
- [📅 Day 2 - 滑动窗口深化：定长平均值的三重奏](#day-2---滑动窗口深化定长平均值的三重奏)
- [📅 Day 3 - 滑动窗口进阶：条件判定与哈希协同](#day-3---滑动窗口进阶条件判定与哈希协同)
- [📅 Day 4 - 滑动窗口深化：逆向思维与边界转化](#day-4---滑动窗口深化逆向思维与边界转化)

---

### Day 1 - 滑动窗口启航：定长窗口的元音之眼  
- **完成题目**：  
  - [x] [1456] 定长子串中元音的最大数目  

- **学习重点**：  
  - 掌握**固定长度滑动窗口的标准维护流程**：右端点扩展 → 窗口满时更新答案 → 左端点收缩；  
  - 理解**窗口有效性判断的核心条件**：`left = i - k + 1 ≥ 0` 是窗口达到长度 `k` 的充要标志；  
  - 实践**增量维护思想**：仅通过加入新字符、移出旧字符，避免重复遍历子串，实现 O(1) 状态转移；  
  - 初识**早停优化策略**：当当前窗口元音数已达理论最大值 `k` 时，可提前终止循环。  

- **卡点反思**：  
  - 初写时混淆了**左端点移出的时机**：曾错误地在更新答案前就执行 `vowel--`，导致当前窗口状态被破坏；  
  - 对“窗口未满时不更新答案”的逻辑缺乏警惕，一度在 `i < k-1` 时也尝试 `max(ans, vowel)`，引入无效比较；  
  - 虽能写出正确代码，但对**为何必须先更新答案再移出左端**的理解停留在“照着模板写”，未从“窗口生命周期”角度内化。  

- **收获与改进**：  
  - 明确了**固定窗口的三步原子操作顺序**：  
    1. **纳入右端**（无条件）；  
    2. **若窗口有效，则更新全局答案**；  
    3. **为下一轮准备，移出左端**（仅当窗口已满）；  
  - 建立了**窗口即状态容器**的认知：窗口内容由左右指针界定，其内部统计量（如元音数）需随指针移动同步更新；  
  - 意识到**边界即正确性**：`left = i - k + 1` 这一简单公式，实则是连接索引与窗口语义的桥梁，未来需对其保持高度敏感；  
  - 已整理详细笔记：[《定长子串中元音的最大数目》](https://github.com/Gelise436b/endless-cheng-leetcode/blob/main/sliding-window/%E5%AE%9A%E9%95%BF%E5%AD%90%E4%B8%B2%E4%B8%AD%E5%85%83%E9%9F%B3%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE.md)  

- **明日计划**：  
  - 手写 [1456] 的 C++ 实现三遍，重点默写窗口边界判断与左右端操作顺序；  
  - 推进灵神题单滑动窗口模块：  
    - [643] 子数组最大平均数 I（巩固定长窗口 + 浮点处理）  
    - [1004] 最大连续1的个数 III（进阶：可变窗口 + 条件松弛）  
  - 开始构建**滑动窗口问题识别 checklist**：  
    - 是否涉及“连续子数组/子串”？  
    - 是否有“长度固定”或“满足某条件的最长/最短”等关键词？  
    - 能否通过左右指针移动维护一个有效区间？  

### Day 2 - 滑动窗口深化：定长平均值的三重奏  
- **完成题目**：  
  - [x] [643] 子数组最大平均数 I  
  - [x] [1343] 大小为 K 且平均值大于等于阈值的子数组数目  
  - [x] [2090] 半径为 k 的子数组平均值  

- **学习重点**：  
  - 提炼并固化**定长滑动窗口的通用三步法**：  
    1. **进入**：无条件纳入右端点元素；  
    2. **更新**：当窗口达到目标长度时，基于当前窗口状态更新答案；  
    3. **退出**：为下一轮迭代准备，移出最左侧元素（仅在窗口已满后执行）；  
  - 掌握**窗口长度与索引关系的灵活映射**：在 [2090] 中，窗口长度为 `2k+1`，右端点 `i` 对应中心位置 `i - k`，实现“以右边界驱动中心计算”的变体逻辑；  
  - 熟悉**不同输出形式下的窗口处理策略**：  
    - [643] 输出最大平均值 → 维护最大和即可（避免重复除法）；  
    - [1343] 输出满足条件的子数组数量 → 判断 `sum >= threshold * k`；  
    - [2090] 输出每个中心的平均值 → 结果写入 `ans[i - k]`，边界由 `i ≥ 2k` 控制；  
  - 强化**数据类型与溢出意识**：使用 `long long` 存储窗口和，防止整数溢出影响正确性。  

- **卡点反思**：  
  - 初写 [2090] 时误将窗口长度当作 `k`，导致除数错误（应为 `2k+1`）及左端点移出位置偏差；  
  - 在 [643] 中曾忽略浮点精度要求，直接用 `int` 存储平均值，后修正为最后统一转 `double`；  
  - 对 [2090] 的“右边界即触发器”逻辑一度困惑：为何不显式维护左指针？后理解其本质仍是三步法，只是**窗口满的判定条件从 `i ≥ k-1` 变为 `i ≥ 2k`**，核心范式未变；  
  - 曾在窗口未满时提前执行“退出”操作，造成负下标访问或状态污染，再次印证“退出仅在窗口有效后发生”的铁律。  

- **收获与改进**：  
  - 确认**三步法具有高度泛化能力**：无论输出是极值、计数还是映射数组，只要问题涉及“固定长度连续子结构”，皆可套用此流程；  
  - 建立**窗口长度 ↔ 触发索引 ↔ 答案位置** 的三角对应关系：  
    - 长度 `L` → 首次有效右端点 `i = L - 1`；  
    - 若答案需关联中心，则中心 `c = i - (L - 1) / 2`（如 [2090] 中 `L=2k+1` ⇒ `c = i - k`）；  
  - 形成**防御性编码习惯**：  
    - 窗口和变量声明为 `long long`；  
    - “退出”操作严格置于“更新”之后，且包裹在 `if (i ≥ L - 1)` 条件内；  
    - 避免在循环早期对答案数组进行无效赋值；  
  - 意识到**变体非新范式，而是旧框架的新装束**：[2090] 表面特殊，实则仍是“右扩 → 满窗更新 → 左缩”的忠实实践者。
  - 已整理详细笔记：[《半径为k的子数组平均值》](https://github.com/Gelise436b/endless-cheng-leetcode/blob/main/sliding-window/%E5%8D%8A%E5%BE%84%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%B9%B3%E5%9D%87%E5%80%BC.md) 

- **明日计划**：  
  - 重做 [2090]，手写两遍，重点默写窗口长度 `2k+1` 与中心索引 `i - k` 的推导逻辑；  
  - 推进灵神题单滑动窗口模块：  
    - [2379] 得到 K 个黑块的最少涂色次数（定长窗口 + 条件计数）  
    - [2841] 几乎唯一子数组的最大和（定长窗口 + 极值更新）  
    - [2461] 长度为 K 子数组中的最大和（定长窗口 + 最大和模板巩固）  
  - 完善**滑动窗口问题识别 checklist**，新增条目：  
    - 若涉及“以某位置为中心”，是否可转化为固定长度窗口？  
    - 窗口长度是否隐含（如半径 `k` ⇒ 长度 `2k+1`）？  
    - 答案位置与当前右端点是否存在确定偏移？
      
### Day 3 - 滑动窗口进阶：条件判定与哈希协同  

- **完成题目**：  
  - [x] [2379] 得到 K 个黑块的最少涂色次数  
  - [x] [2841] 几乎唯一子数组的最大和  
  - [x] [2461] 长度为 K 子数组中的最大和  

- **学习重点**：  
  - **定长窗口 + 复杂条件判定**成为今日核心挑战：  
    - [2379] 转化为“长度为 K 的窗口中，最少将多少白块（'W'）改为黑块（'B'）”，等价于 **最小化窗口内 'W' 的数量**；  
    - [2461] 是经典模板题，巩固“固定长度窗口最大和”结构，强调 `long long` 防溢出与三步法节奏；  
    - [2841] 引入**元素多样性约束**（不同数字种类 ≥ m），需借助哈希表动态维护频次并利用 `map.size()` 判断合法性；  
  - **哈希表在滑动窗口中的精准维护**：  
    - 进入：`cnt[nums[i]]++`；  
    - 更新：仅当 `i ≥ k - 1` 且 `cnt.size() ≥ m` 时尝试更新答案；  
    - 退出：移除左端点元素后，若其计数归零，**必须执行 `erase`**，否则 `size()` 将包含无效键，导致条件误判；  
  - **问题转化能力提升**：  
    - [2379] 将字符串操作抽象为数值统计（'W' → 1，'B' → 0），转化为“定长子数组最小和”；  
    - [2841] 将“几乎唯一”语义转化为“不同元素种类数 ≥ m”，实现从自然语言到数学条件的映射；  
  - **统一框架下的策略分化**：  
    - 极值类（[2461], [2841]）→ 维护 `max_sum`；  
    - 最优操作类（[2379]）→ 维护 `min_count`；  
    - 条件满足类（[2841]）→ 引入辅助数据结构（map）进行状态验证。  

- **卡点反思**：  
  - 初解 [2841] 时，**未理解“几乎唯一”的准确含义**，误以为是“最多 m 种”或“恰好 m 种”，后通过题解明确为“至少 m 种不同元素”；  
  - 尝试用 `vector<int>` 或 `unordered_set` 实现去重，但无法处理重复元素的进出逻辑，**意识到频次统计不可省略**；  
  - 在滑窗退出阶段，**忘记对计数归零的键执行 `erase`**，导致 `map.size()` 虚高，使非法窗口被误判为合法，答案偏大；  
  - [2379] 中曾直接对字符操作，未转化为整型统计，代码冗余且易错，后改用预处理或在线判断 `s[i]=='W'` 简化逻辑；  
  - 对 [2461] 的边界处理稍显犹豫，担心 `k == nums.size()` 时左指针越界，实则三步法天然兼容全数组窗口。  

- **收获与改进**：  
  - **确认哈希表是处理“元素种类”类窗口问题的标准工具**，而 `size()` 的正确性依赖于**及时清理零频次键**；  
  - 建立 **“条件是否可增量维护”判断准则**：  
    - 若条件依赖集合大小、频次分布、唯一性等 → 引入 map/set；  
    - 若条件仅依赖和、最值、计数 → 无需额外结构；  
  - 强化 **“三步法 + 辅助结构”组合范式**：  
    ```cpp
    for (int i = 0; i < n; ++i) {
        // 1. 进入
        add(nums[i]);
        // 2. 更新（窗口满时）
        if (i >= k - 1) {
            if (valid()) ans = update(ans);
            // 3. 退出（为下一轮准备）
            remove(nums[i - k + 1]);
        }
    }
    ```  
  - 形成 **调试此类问题的 checklist**：  
    - map 是否在 `--cnt[x] == 0` 时 erase？  
    - 窗口满的判断是否为 `i >= k - 1`？  
    - 答案更新是否仅在窗口有效且条件满足时触发？  
  - 意识到 **“几乎唯一”是滑动窗口 + 哈希计数的经典交汇点**，未来遇到“多样性”“独特性”“种类数”等关键词，应立即联想此模式。
  - 已整理详细笔记：[《几乎唯一子数组的最大和》](https://github.com/Gelise436b/endless-cheng-leetcode/blob/main/sliding-window/%E5%87%A0%E4%B9%8E%E5%94%AF%E4%B8%80%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.md)  

- **明日计划**：  
  - 重做 [2841]，手写两遍，重点演练 `map` 的增删逻辑与 `size()` 的语义保障；  
  - 推进灵神题单滑动窗口模块：  
    - [1423] 可获得的最大点数（双端定长窗口 / 前缀和转化）  
    - [1176] 健身计划（变长窗口 + 二分 or 双指针，但先尝试定长思维迁移）  
    - [1100] 长度为 K 的无重复字符子串（定长 + 哈希去重，强化 `erase` 习惯）  
  - 完善**滑动窗口问题识别 checklist**，新增条目：  
    - 问题是否涉及“不同元素种类数”？ → 引入 map/set + erase 零频次；  
    - 条件是否可在 O(1) 内由辅助结构验证？ → 否则考虑其他算法；  
    - 窗口操作是否对称（如 [1423] 两端取）？ → 考虑补集思想或前缀和转化。
      
### Day 4 - 滑动窗口深化：逆向思维与边界转化  

- **完成题目**：  
  - [x] [1423] 可获得的最大点数  
  - [x] [1176] 健身计划  
  - [x] [1100] 长度为 K 的无重复字符子串  

- **学习重点**：  
  - **逆向思维在滑动窗口中的关键作用**：  
    - [1423] 本质是**从数组两端取共 k 张卡片**，看似无法用传统滑窗处理；但通过**补集思想**，将其转化为“在中间 n−k 个元素中找最小连续子数组和”，从而复用定长滑窗模板；  
    - 正向思路（枚举前 i 张 + 后 k−i 张）虽可行，但需维护前缀/后缀和，代码冗余且边界易错；而逆向解法仅需一次滑窗 + 总和减去最小窗口和，简洁高效；  
  - **C++ 标准库认知补全**：  
    - 初次接触 `std::reduce` 误以为是通用聚合函数，实则为 C++17 起支持的**并行求和函数**，等价于 `accumulate(..., 0)`；在 LeetCode 环境中更推荐使用 `accumulate` 以确保兼容性；  
  - **变长窗口与定长窗口的判别**：  
    - [1176] 表面是“连续 k 天”，实为**固定长度窗口评分问题**，与 Day 3 的健身计划题一致，强化了“窗口满时才评分”的条件触发逻辑；  
    - [1100] 是典型**定长 + 无重复约束**问题，需结合哈希表维护字符频次，并严格在移除左端点后 `erase` 零频次键，保障 `map.size() == k` 作为合法窗口判据；  
  - **统一解题范式再验证**：  
    - 极值类（[1423]）→ 总和 − 最小窗口和；  
    - 条件评分类（[1176]）→ 滑窗 + 分段判断；  
    - 唯一性约束类（[1100]）→ 定长滑窗 + 哈希去重 + erase 保障。  

- **卡点反思**：  
  - 面对 [1423] 时，**陷入“只能从两端取”的直觉陷阱**，未意识到剩余部分必为连续子数组，导致无法建立滑窗模型；  
  - 尝试正向枚举（前 i 后 k−i）时，因未预计算前缀/后缀和，导致每次求和 O(k)，整体复杂度退化至 O(k²)，效率低下；  
  - 对 `std::reduce` 的存在和语义不熟悉，在本地调试时报错，浪费时间排查环境问题，暴露了对 C++17 新特性的掌握不足；  
  - [1100] 中曾忽略“长度恰好为 K”这一硬性条件，误用变长窗口模板（如最长无重复子串），导致逻辑混乱；  
  - [1176] 的窗口起始位置判断稍显迟疑，担心 `i < k-1` 时提前评分，后确认“仅当 `i >= k-1` 才构成完整窗口”可安全规避。  

- **收获与改进**：  
  - **确立“补集转化”为滑动窗口高阶技巧**：当操作对象为“两端”或“非连续选取”时，优先思考“中间连续部分”的性质；  
  - **形成“定长窗口三要素”检查清单**：  
    - 窗口长度是否固定？ → 是 → 用 `i >= k-1` 触发更新；  
    - 是否需总和/最值？ → 用 `accumulate` 或滑窗和；  
    - 是否有唯一性/种类约束？ → 引入 map + erase 零频次；  
  - **强化标准库使用规范**：  
    - 在 LeetCode 或兼容性敏感场景，优先使用 `std::accumulate` 替代 `std::reduce`；  
    - 明确 `accumulate` 需显式传初始值（如 `0LL` 防溢出）；  
  - **建立“问题结构识别”反射**：  
    - “从两端取 k 个” → 补集 → 中间 n−k 连续 → 最小和；  
    - “连续 k 天评分” → 定长滑窗 + 条件分支；  
    - “长度为 K 且无重复” → 定长 + map.size() == K；  
  - 意识到**正向枚举并非总是最优**，有时逆向建模能将 O(k) 枚举降为 O(n) 单次滑窗。
  - 已整理详细笔记：[《可获得的最大点数》](https://github.com/Gelise436b/endless-cheng-leetcode/blob/main/sliding-window/%E5%8F%AF%E8%8E%B7%E5%BE%97%E7%9A%84%E6%9C%80%E5%A4%A7%E7%82%B9%E6%95%B0.md)  

- **明日计划**：  
  - **重做 [1423]**，手写两种解法（逆向滑窗 + 正向前缀/后缀和），对比代码简洁性与性能；  
  - 推进灵神题单滑动窗口模块：  
    - [1852] 每个子数组的数字和（定长滑窗 + 哈希计数，注意负数处理）  
    - [1151] 最少交换次数使数组元素相等（环形数组 + 滑窗，需转化问题）  
    - [2107] 含特定字符的子序列数目（非连续？需重新审题，可能非滑窗，先判断）  
  - 完善**滑动窗口适用性决策树**，新增分支：  
    - 操作对象是否为“两端”？ → 是 → 考虑补集转化为中间连续段；  
    - 是否必须恰好长度 K？ → 是 → 禁用变长窗口模板；  
    - 元素是否可重复？约束是否基于种类？ → 是 → map + erase 必备。
