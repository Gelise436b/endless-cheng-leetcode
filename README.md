# LeetCode 灵神题单精研笔记  
> **从范式启航，向思维深处漫溯**  

---

## 📅 学习日志  
## 📚 目录

- [📅 Day 1 - 滑动窗口启航：定长窗口的元音之眼](#day-1---滑动窗口启航定长窗口的元音之眼)
- [📅 Day 2 - 滑动窗口深化：定长平均值的三重奏](#day-2---滑动窗口深化定长平均值的三重奏)
- [📅 Day 3 - 滑动窗口进阶：条件判定与哈希协同](#day-3---滑动窗口进阶条件判定与哈希协同)
- [📅 Day 4 - 滑动窗口深化：逆向思维与边界转化](#day-4---滑动窗口深化逆向思维与边界转化)
- [📅 Day 5 - 滑动窗口高阶应用：剩余集维护与问题建模再校准](#day-5---滑动窗口高阶应用剩余集维护与问题建模再校准)
- [📅 Day 6 - 滑动窗口的语义建模与状态分离策略](#day-6---滑动窗口的语义建模与状态分离策略)
- [📅 Day 7 - 回归基础与认知边界校准](#day-7---回归基础与认知边界校准)
- [📅 Day 8 - 不定长滑动窗口的建模与逆向思维训练](#day-8---不定长滑动窗口的建模与逆向思维训练)

---

### Day 1 - 滑动窗口启航：定长窗口的元音之眼  
- **完成题目**：  
  - [x] [1456] 定长子串中元音的最大数目  

- **学习重点**：  
  - 掌握**固定长度滑动窗口的标准维护流程**：右端点扩展 → 窗口满时更新答案 → 左端点收缩；  
  - 理解**窗口有效性判断的核心条件**：`left = i - k + 1 ≥ 0` 是窗口达到长度 `k` 的充要标志；  
  - 实践**增量维护思想**：仅通过加入新字符、移出旧字符，避免重复遍历子串，实现 O(1) 状态转移；  
  - 初识**早停优化策略**：当当前窗口元音数已达理论最大值 `k` 时，可提前终止循环。  

- **卡点反思**：  
  - 初写时混淆了**左端点移出的时机**：曾错误地在更新答案前就执行 `vowel--`，导致当前窗口状态被破坏；  
  - 对“窗口未满时不更新答案”的逻辑缺乏警惕，一度在 `i < k-1` 时也尝试 `max(ans, vowel)`，引入无效比较；  
  - 虽能写出正确代码，但对**为何必须先更新答案再移出左端**的理解停留在“照着模板写”，未从“窗口生命周期”角度内化。  

- **收获与改进**：  
  - 明确了**固定窗口的三步原子操作顺序**：  
    1. **纳入右端**（无条件）；  
    2. **若窗口有效，则更新全局答案**；  
    3. **为下一轮准备，移出左端**（仅当窗口已满）；  
  - 建立了**窗口即状态容器**的认知：窗口内容由左右指针界定，其内部统计量（如元音数）需随指针移动同步更新；  
  - 意识到**边界即正确性**：`left = i - k + 1` 这一简单公式，实则是连接索引与窗口语义的桥梁，未来需对其保持高度敏感；  
  - 已整理详细笔记：[《定长子串中元音的最大数目》](https://github.com/Gelise436b/endless-cheng-leetcode/blob/main/sliding-window/%E5%AE%9A%E9%95%BF%E5%AD%90%E4%B8%B2%E4%B8%AD%E5%85%83%E9%9F%B3%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE.md)  

- **明日计划**：  
  - 手写 [1456] 的 C++ 实现三遍，重点默写窗口边界判断与左右端操作顺序；  
  - 推进灵神题单滑动窗口模块：  
    - [643] 子数组最大平均数 I（巩固定长窗口 + 浮点处理）  
    - [1004] 最大连续1的个数 III（进阶：可变窗口 + 条件松弛）  
  - 开始构建**滑动窗口问题识别 checklist**：  
    - 是否涉及“连续子数组/子串”？  
    - 是否有“长度固定”或“满足某条件的最长/最短”等关键词？  
    - 能否通过左右指针移动维护一个有效区间？  

### Day 2 - 滑动窗口深化：定长平均值的三重奏  
- **完成题目**：  
  - [x] [643] 子数组最大平均数 I  
  - [x] [1343] 大小为 K 且平均值大于等于阈值的子数组数目  
  - [x] [2090] 半径为 k 的子数组平均值  

- **学习重点**：  
  - 提炼并固化**定长滑动窗口的通用三步法**：  
    1. **进入**：无条件纳入右端点元素；  
    2. **更新**：当窗口达到目标长度时，基于当前窗口状态更新答案；  
    3. **退出**：为下一轮迭代准备，移出最左侧元素（仅在窗口已满后执行）；  
  - 掌握**窗口长度与索引关系的灵活映射**：在 [2090] 中，窗口长度为 `2k+1`，右端点 `i` 对应中心位置 `i - k`，实现“以右边界驱动中心计算”的变体逻辑；  
  - 熟悉**不同输出形式下的窗口处理策略**：  
    - [643] 输出最大平均值 → 维护最大和即可（避免重复除法）；  
    - [1343] 输出满足条件的子数组数量 → 判断 `sum >= threshold * k`；  
    - [2090] 输出每个中心的平均值 → 结果写入 `ans[i - k]`，边界由 `i ≥ 2k` 控制；  
  - 强化**数据类型与溢出意识**：使用 `long long` 存储窗口和，防止整数溢出影响正确性。  

- **卡点反思**：  
  - 初写 [2090] 时误将窗口长度当作 `k`，导致除数错误（应为 `2k+1`）及左端点移出位置偏差；  
  - 在 [643] 中曾忽略浮点精度要求，直接用 `int` 存储平均值，后修正为最后统一转 `double`；  
  - 对 [2090] 的“右边界即触发器”逻辑一度困惑：为何不显式维护左指针？后理解其本质仍是三步法，只是**窗口满的判定条件从 `i ≥ k-1` 变为 `i ≥ 2k`**，核心范式未变；  
  - 曾在窗口未满时提前执行“退出”操作，造成负下标访问或状态污染，再次印证“退出仅在窗口有效后发生”的铁律。  

- **收获与改进**：  
  - 确认**三步法具有高度泛化能力**：无论输出是极值、计数还是映射数组，只要问题涉及“固定长度连续子结构”，皆可套用此流程；  
  - 建立**窗口长度 ↔ 触发索引 ↔ 答案位置** 的三角对应关系：  
    - 长度 `L` → 首次有效右端点 `i = L - 1`；  
    - 若答案需关联中心，则中心 `c = i - (L - 1) / 2`（如 [2090] 中 `L=2k+1` ⇒ `c = i - k`）；  
  - 形成**防御性编码习惯**：  
    - 窗口和变量声明为 `long long`；  
    - “退出”操作严格置于“更新”之后，且包裹在 `if (i ≥ L - 1)` 条件内；  
    - 避免在循环早期对答案数组进行无效赋值；  
  - 意识到**变体非新范式，而是旧框架的新装束**：[2090] 表面特殊，实则仍是“右扩 → 满窗更新 → 左缩”的忠实实践者。
  - 已整理详细笔记：[《半径为k的子数组平均值》](https://github.com/Gelise436b/endless-cheng-leetcode/blob/main/sliding-window/%E5%8D%8A%E5%BE%84%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%B9%B3%E5%9D%87%E5%80%BC.md) 

- **明日计划**：  
  - 重做 [2090]，手写两遍，重点默写窗口长度 `2k+1` 与中心索引 `i - k` 的推导逻辑；  
  - 推进灵神题单滑动窗口模块：  
    - [2379] 得到 K 个黑块的最少涂色次数（定长窗口 + 条件计数）  
    - [2841] 几乎唯一子数组的最大和（定长窗口 + 极值更新）  
    - [2461] 长度为 K 子数组中的最大和（定长窗口 + 最大和模板巩固）  
  - 完善**滑动窗口问题识别 checklist**，新增条目：  
    - 若涉及“以某位置为中心”，是否可转化为固定长度窗口？  
    - 窗口长度是否隐含（如半径 `k` ⇒ 长度 `2k+1`）？  
    - 答案位置与当前右端点是否存在确定偏移？
      
### Day 3 - 滑动窗口进阶：条件判定与哈希协同  

- **完成题目**：  
  - [x] [2379] 得到 K 个黑块的最少涂色次数  
  - [x] [2841] 几乎唯一子数组的最大和  
  - [x] [2461] 长度为 K 子数组中的最大和  

- **学习重点**：  
  - **定长窗口 + 复杂条件判定**成为今日核心挑战：  
    - [2379] 转化为“长度为 K 的窗口中，最少将多少白块（'W'）改为黑块（'B'）”，等价于 **最小化窗口内 'W' 的数量**；  
    - [2461] 是经典模板题，巩固“固定长度窗口最大和”结构，强调 `long long` 防溢出与三步法节奏；  
    - [2841] 引入**元素多样性约束**（不同数字种类 ≥ m），需借助哈希表动态维护频次并利用 `map.size()` 判断合法性；  
  - **哈希表在滑动窗口中的精准维护**：  
    - 进入：`cnt[nums[i]]++`；  
    - 更新：仅当 `i ≥ k - 1` 且 `cnt.size() ≥ m` 时尝试更新答案；  
    - 退出：移除左端点元素后，若其计数归零，**必须执行 `erase`**，否则 `size()` 将包含无效键，导致条件误判；  
  - **问题转化能力提升**：  
    - [2379] 将字符串操作抽象为数值统计（'W' → 1，'B' → 0），转化为“定长子数组最小和”；  
    - [2841] 将“几乎唯一”语义转化为“不同元素种类数 ≥ m”，实现从自然语言到数学条件的映射；  
  - **统一框架下的策略分化**：  
    - 极值类（[2461], [2841]）→ 维护 `max_sum`；  
    - 最优操作类（[2379]）→ 维护 `min_count`；  
    - 条件满足类（[2841]）→ 引入辅助数据结构（map）进行状态验证。  

- **卡点反思**：  
  - 初解 [2841] 时，**未理解“几乎唯一”的准确含义**，误以为是“最多 m 种”或“恰好 m 种”，后通过题解明确为“至少 m 种不同元素”；  
  - 尝试用 `vector<int>` 或 `unordered_set` 实现去重，但无法处理重复元素的进出逻辑，**意识到频次统计不可省略**；  
  - 在滑窗退出阶段，**忘记对计数归零的键执行 `erase`**，导致 `map.size()` 虚高，使非法窗口被误判为合法，答案偏大；  
  - [2379] 中曾直接对字符操作，未转化为整型统计，代码冗余且易错，后改用预处理或在线判断 `s[i]=='W'` 简化逻辑；  
  - 对 [2461] 的边界处理稍显犹豫，担心 `k == nums.size()` 时左指针越界，实则三步法天然兼容全数组窗口。  

- **收获与改进**：  
  - **确认哈希表是处理“元素种类”类窗口问题的标准工具**，而 `size()` 的正确性依赖于**及时清理零频次键**；  
  - 建立 **“条件是否可增量维护”判断准则**：  
    - 若条件依赖集合大小、频次分布、唯一性等 → 引入 map/set；  
    - 若条件仅依赖和、最值、计数 → 无需额外结构；  
  - 强化 **“三步法 + 辅助结构”组合范式**：  
    ```cpp
    for (int i = 0; i < n; ++i) {
        // 1. 进入
        add(nums[i]);
        // 2. 更新（窗口满时）
        if (i >= k - 1) {
            if (valid()) ans = update(ans);
            // 3. 退出（为下一轮准备）
            remove(nums[i - k + 1]);
        }
    }
    ```  
  - 形成 **调试此类问题的 checklist**：  
    - map 是否在 `--cnt[x] == 0` 时 erase？  
    - 窗口满的判断是否为 `i >= k - 1`？  
    - 答案更新是否仅在窗口有效且条件满足时触发？  
  - 意识到 **“几乎唯一”是滑动窗口 + 哈希计数的经典交汇点**，未来遇到“多样性”“独特性”“种类数”等关键词，应立即联想此模式。
  - 已整理详细笔记：[《几乎唯一子数组的最大和》](https://github.com/Gelise436b/endless-cheng-leetcode/blob/main/sliding-window/%E5%87%A0%E4%B9%8E%E5%94%AF%E4%B8%80%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.md)  

- **明日计划**：  
  - 重做 [2841]，手写两遍，重点演练 `map` 的增删逻辑与 `size()` 的语义保障；  
  - 推进灵神题单滑动窗口模块：  
    - [1423] 可获得的最大点数（双端定长窗口 / 前缀和转化）  
    - [1176] 健身计划（变长窗口 + 二分 or 双指针，但先尝试定长思维迁移）  
    - [1100] 长度为 K 的无重复字符子串（定长 + 哈希去重，强化 `erase` 习惯）  
  - 完善**滑动窗口问题识别 checklist**，新增条目：  
    - 问题是否涉及“不同元素种类数”？ → 引入 map/set + erase 零频次；  
    - 条件是否可在 O(1) 内由辅助结构验证？ → 否则考虑其他算法；  
    - 窗口操作是否对称（如 [1423] 两端取）？ → 考虑补集思想或前缀和转化。
      
### Day 4 - 滑动窗口深化：逆向思维与边界转化  

- **完成题目**：  
  - [x] [1423] 可获得的最大点数  
  - [x] [1176] 健身计划  
  - [x] [1100] 长度为 K 的无重复字符子串  

- **学习重点**：  
  - **逆向思维在滑动窗口中的关键作用**：  
    - [1423] 本质是**从数组两端取共 k 张卡片**，看似无法用传统滑窗处理；但通过**补集思想**，将其转化为“在中间 n−k 个元素中找最小连续子数组和”，从而复用定长滑窗模板；  
    - 正向思路（枚举前 i 张 + 后 k−i 张）虽可行，但需维护前缀/后缀和，代码冗余且边界易错；而逆向解法仅需一次滑窗 + 总和减去最小窗口和，简洁高效；  
  - **C++ 标准库认知补全**：  
    - 初次接触 `std::reduce` 误以为是通用聚合函数，实则为 C++17 起支持的**并行求和函数**，等价于 `accumulate(..., 0)`；在 LeetCode 环境中更推荐使用 `accumulate` 以确保兼容性；  
  - **变长窗口与定长窗口的判别**：  
    - [1176] 表面是“连续 k 天”，实为**固定长度窗口评分问题**，与 Day 3 的健身计划题一致，强化了“窗口满时才评分”的条件触发逻辑；  
    - [1100] 是典型**定长 + 无重复约束**问题，需结合哈希表维护字符频次，并严格在移除左端点后 `erase` 零频次键，保障 `map.size() == k` 作为合法窗口判据；  
  - **统一解题范式再验证**：  
    - 极值类（[1423]）→ 总和 − 最小窗口和；  
    - 条件评分类（[1176]）→ 滑窗 + 分段判断；  
    - 唯一性约束类（[1100]）→ 定长滑窗 + 哈希去重 + erase 保障。  

- **卡点反思**：  
  - 面对 [1423] 时，**陷入“只能从两端取”的直觉陷阱**，未意识到剩余部分必为连续子数组，导致无法建立滑窗模型；  
  - 尝试正向枚举（前 i 后 k−i）时，因未预计算前缀/后缀和，导致每次求和 O(k)，整体复杂度退化至 O(k²)，效率低下；  
  - 对 `std::reduce` 的存在和语义不熟悉，在本地调试时报错，浪费时间排查环境问题，暴露了对 C++17 新特性的掌握不足；  
  - [1100] 中曾忽略“长度恰好为 K”这一硬性条件，误用变长窗口模板（如最长无重复子串），导致逻辑混乱；  
  - [1176] 的窗口起始位置判断稍显迟疑，担心 `i < k-1` 时提前评分，后确认“仅当 `i >= k-1` 才构成完整窗口”可安全规避。  

- **收获与改进**：  
  - **确立“补集转化”为滑动窗口高阶技巧**：当操作对象为“两端”或“非连续选取”时，优先思考“中间连续部分”的性质；  
  - **形成“定长窗口三要素”检查清单**：  
    - 窗口长度是否固定？ → 是 → 用 `i >= k-1` 触发更新；  
    - 是否需总和/最值？ → 用 `accumulate` 或滑窗和；  
    - 是否有唯一性/种类约束？ → 引入 map + erase 零频次；  
  - **强化标准库使用规范**：  
    - 在 LeetCode 或兼容性敏感场景，优先使用 `std::accumulate` 替代 `std::reduce`；  
    - 明确 `accumulate` 需显式传初始值（如 `0LL` 防溢出）；  
  - **建立“问题结构识别”反射**：  
    - “从两端取 k 个” → 补集 → 中间 n−k 连续 → 最小和；  
    - “连续 k 天评分” → 定长滑窗 + 条件分支；  
    - “长度为 K 且无重复” → 定长 + map.size() == K；  
  - 意识到**正向枚举并非总是最优**，有时逆向建模能将 O(k) 枚举降为 O(n) 单次滑窗。
  - 已整理详细笔记：[《可获得的最大点数》](https://github.com/Gelise436b/endless-cheng-leetcode/blob/main/sliding-window/%E5%8F%AF%E8%8E%B7%E5%BE%97%E7%9A%84%E6%9C%80%E5%A4%A7%E7%82%B9%E6%95%B0.md)  

- **明日计划**：  
  - **重做 [1423]**，手写两种解法（逆向滑窗 + 正向前缀/后缀和），对比代码简洁性与性能；  
  - 推进灵神题单滑动窗口模块：  
    - [1852] 每个子数组的数字和（定长滑窗 + 哈希计数，注意负数处理）  
    - [1151] 最少交换次数使数组元素相等（环形数组 + 滑窗，需转化问题）  
    - [2107] 含特定字符的子序列数目（非连续？需重新审题，可能非滑窗，先判断）  
  - 完善**滑动窗口适用性决策树**，新增分支：  
    - 操作对象是否为“两端”？ → 是 → 考虑补集转化为中间连续段；  
    - 是否必须恰好长度 K？ → 是 → 禁用变长窗口模板；  
    - 元素是否可重复？约束是否基于种类？ → 是 → map + erase 必备。
    - 
### Day 5 - 滑动窗口高阶应用：剩余集维护与问题建模再校准  

- **完成题目**：  
  - [x] [1852] 每个子数组的数字和  
  - [x] [1151] 最少交换次数使所有 1 聚合  
  - [x] [2107] 分享 K 个糖果后独特口味的数量  

- **学习重点**：  
  - **滑动窗口的核心对象决定解法方向**：  
    - [2107] 的关键突破在于**放弃对“被拿走窗口”的分析**，转而**直接维护“剩余 n−k 个元素”的哈希状态**；窗口滑动时，动态更新剩余集合的频次，其 `map.size()` 即为当前合法答案，避免了“窗口种类数 ≠ 被移除种类数”的经典误判；  
    - 对比 [1151]（求最小交换次数）：其本质是**固定长度窗口内 0 的最小数量**，因交换次数 = 窗口内非目标元素数，此时分析“被选中窗口”本身是合理的；而 [2107] 因涉及“全局频次完整性”，必须从剩余侧建模；  
  - **问题建模范式的精准匹配**：  
    - “最少交换使 1 聚合” → 定长滑窗 + 窗口内 0 的最小值；  
    - “分享 k 个后最大独特口味” → 定长滑窗 + **剩余部分种类数的最大值**；  
    - 二者虽同为定长滑窗，但**优化目标作用的对象截然不同**（前者关注窗口内部，后者关注窗口外部）；  
  - **哈希表维护的工程细节**：  
    - 在 [2107] 中，每次移除元素后需显式 `erase` 零频次键，否则 `map.size()` 会虚高；  
    - 初始化剩余集时，应从索引 `k` 开始填充，确保初始状态对应“拿走前 k 个”的场景；  
    - 滑动过程中，**加回左边界（i−1）、移出右边界（i+k−1）** 的操作顺序与窗口移动方向严格一致；  
  - **负数与溢出的鲁棒性处理**：  
    - [1852] 涉及子数组和的哈希计数，需注意前缀和可能为负，`unordered_map` 可天然支持；  
    - 累加时使用 `long long` 防止整型溢出，尤其在 LeetCode 极端测试用例下。  

- **卡点反思**：  
  - **[2107] 初期陷入严重建模误区**：试图通过“最小化被拿走窗口的种类数”来最大化剩余种类，忽略了“某口味是否被完全移除”取决于其**全局频次与窗口频次的相等性**，而非窗口是否包含该口味；  
  - 曾错误复用 [1151] 的思路，将 `ans = totalTypes - min_window_size` 作为答案，导致在 `[1,2,2,3,4,3], k=3` 等用例上输出 2（期望 3）；  
  - 调试时未及时打印中间状态，导致难以定位“窗口种类数”与“实际被移除种类数”的差异；  
  - [1852] 中一度混淆“子数组和”与“子序列和”，险些误入 DP 路线，后通过题干“连续子数组”关键词回归滑窗+前缀和正轨；  
  - [1151] 虽顺利 AC，但未深究其与环形数组变种（如 [LCR 010]）的联系，错失拓展机会。  

- **收获与改进**：  
  - **确立“剩余集维护”为一类独立滑窗范式**：当问题目标依赖于“未被选中部分”的性质（如种类、和、存在性）时，优先考虑直接建模剩余集合，而非通过补集间接推导；  
  - **形成“滑窗作用域”判断准则**：  
    - 若答案由**窗口内部属性**决定（如和、最值、0 的数量）→ 分析窗口本身；  
    - 若答案由**窗口外部属性**决定（如剩余种类、剩余和）→ 直接维护剩余集；  
  - **强化调试意识**：对逻辑复杂的滑窗题，主动添加 `cout` 打印 `map.size()`、关键变量值，快速验证中间状态；  
  - **明确 [2107] 的普适价值**：该题是“外部依赖型滑窗”的典型代表，可迁移至“删除一段后最大化剩余多样性”类问题（如字符串、数组去重场景）；  
  - 已整理详细笔记：[《分享k个糖果后独特口味的数量》](https://github.com/Gelise436b/endless-cheng-leetcode/blob/main/sliding-window/%E5%88%86%E4%BA%ABk%E4%B8%AA%E7%B3%96%E6%9E%9C%E5%90%8E%E7%8B%AC%E7%89%B9%E5%8F%A3%E5%91%B3%E7%9A%84%E6%95%B0%E9%87%8F.md)   

- **明日计划**：  
  - **深度复习 [2107]**：手写两种视角代码（错误的“窗口种类最小化” vs 正确的“剩余种类最大化”），对比逻辑差异与测试用例表现；  
  - 推进灵神题单滑动窗口模块：  
    - [3679] 满足条件的子序列数目（注意：题干若为“子序列”则非滑窗，需先确认是否为“子数组”；若是子数组，则可能为定长/变长滑窗 + 哈希/双指针）；  
    - [1052] 爱生气的书店老板（经典“翻转 k 个 0 使 1 最多”模型，转化为定长滑窗内 0 的最大数量）；  
    - [3439] 特定条件下子数组计数（预判为变长滑窗 + 哈希前缀和，需处理负数与模运算）；  
  - 完善**滑动窗口适用性决策树**，新增分支：  
    - 问题目标是否依赖“未被窗口覆盖的部分”？ → 是 → 采用剩余集维护策略；  
    - 是否涉及“全局频次完整性”判断？ → 是 → 必须记录 totalFreq 并对比 windowFreq（或直接维护剩余集）；  
    - 操作是否可逆且局部？ → 是 → 滑窗增删 O(1) 更新可行。
      
### Day 6 - 滑动窗口的语义建模与状态分离策略  

- **完成题目**：  
  - [x] [3679] 使库存平衡的最少丢弃次数  
  - [x] [1052] 爱生气的书店老板  
  - [x] [3439] 特定条件下子数组计数（空余时间段滑窗）  

- **学习重点**：  
  - **问题语义的精准解耦决定算法路径**：  
    - [3679] 的核心在于理解“丢弃”是**被动响应**而非主动过滤：只有当保留当前物品会导致**最近 `w` 天内该类型保留数量 > m** 时，才丢弃**这一次**；并非“一旦累计达 `m` 就永久拒绝”，更非“不入队”。正确模型应为**动态维护一个最多含 `w` 个元素的保留队列**，仅对保留项计数；  
    - [1052] 的关键突破是**将满意度拆解为两个独立部分**：  
      - **基础满意度**：所有 `grumpy[i] == 0` 的 `customers[i]` 之和（固定不变）；  
      - **可提升满意度**：在任意连续 `minutes` 窗口内，`grumpy[i] == 1` 的 `customers[i]` 之和（需最大化）；  
      - 最终答案 = 基础满意度 + 可提升满意度的最大值 → **无需二维数组，只需一维滑窗维护“生气时段的顾客和”**；  
    - [3439] 的洞察在于**将原始时间轴转化为“空余时间序列”**：若原问题描述为“在 `n` 天中安排 `k` 次移动，每次移动消耗 1 单位空闲时间”，则可预处理出每日空余时间数组 `idle[]`，问题转化为**在 `idle` 上求长度为 `k` 的子数组最大和** → 标准定长滑窗；  
  - **状态维护的边界一致性**：  
    - [3679] 中，窗口大小由**已保留物品数量**决定，而非原始天数；滑出操作仅在保留队列满 `w` 时触发；  
    - [1052] 中，滑窗长度严格等于 `minutes`，窗口滑动时需同步减去左边界（若当时生气）；  
    - [3439] 中，窗口长度等于“可执行操作次数”（如 `k` 次移动），需确保 `idle` 数组长度 ≥ `k`；  
  - **避免过度工程化**：  
    - [1052] 无需 `s[2]` 数组或二维结构，`s[0]` 可离线计算，`s[1]` 用单变量滑窗即可；  
    - [3679] 的“改值为 0” hack 虽可行，但**显式队列+计数器**更鲁棒，且逻辑自解释；  

- **卡点反思**：  
  - **[3679] 初期严重误读题意**：将“窗口内保留数量超限导致本次丢弃”误解为“全局达 `m` 后永久拒绝该类型”，导致错误地跳过后续同类型物品，未意识到**每个窗口独立判断、丢弃不影响未来**；  
  - **[1052] 陷入结构复杂化陷阱**：试图用二维数组分别记录生气/不生气的前缀和，忽略了“基础满意度可预计算、增量收益仅来自生气时段”的分离性，导致代码冗余且难以调试；  
  - **[3439] 完全未能建立问题映射**：困于原始时间轴描述，未想到将“可用资源”抽象为数组元素，错失滑窗建模机会；暴露了**从应用语境到数学模型的转化能力不足**；  
  - 三题均因**未先手写小规模模拟**而延长 debug 时间，尤其 [3679] 在 `w=1, m=1` 等边界用例上行为反直觉；  

- **收获与改进**：  
  - **确立“状态分离”为滑窗设计首要原则**：当问题包含**固定部分 + 可变部分**时（如 [1052] 的满意/可挽回顾客），优先拆解并独立处理；  
  - **强化“问题重述”能力**：面对复杂题干（如 [3439]），强制自己用一句话概括核心操作（例：“求 k 个连续空余时间的最大总和”），再匹配算法范式；  
  - **明确三类滑窗适用场景**：  
    - **内部属性优化**（[1151]）：窗口内 0 的最小数量；  
    - **外部属性优化**（[2107]）：剩余集合种类数最大；  
    - **混合状态分离**（[1052], [3679]）：固定收益 + 窗口内可变收益；  
  - **放弃“hack 式编码”**：[3679] 中改写输入数组虽简洁，但牺牲可读性与健壮性；今后优先采用**显式状态容器**（如 `queue<int> kept`）；  
  - 已更新笔记：[使库存平衡的最少丢弃次数](https://github.com/Gelise436b/endless-cheng-leetcode/blob/main/sliding-window/%E4%BD%BF%E5%BA%93%E5%AD%98%E5%B9%B3%E8%A1%A1%E7%9A%84%E6%9C%80%E5%B0%91%E4%B8%A2%E5%BC%83%E6%AC%A1%E6%95%B0.md),[爱生气的书店老板](https://github.com/Gelise436b/endless-cheng-leetcode/blob/main/sliding-window/%E7%88%B1%E7%94%9F%E6%B0%94%E7%9A%84%E4%B9%A6%E5%BA%97%E8%80%81%E6%9D%BF.md),[重新安排会议得到最多空余时间I](https://github.com/Gelise436b/endless-cheng-leetcode/blob/main/sliding-window/%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E4%BC%9A%E8%AE%AE%E5%BE%97%E5%88%B0%E6%9C%80%E5%A4%9A%E7%A9%BA%E4%BD%99%E6%97%B6%E9%97%B4I.md)

- **明日计划**：  
  - **深度复盘今日三题**：  
    - 手写 [3679] 两种实现（hack 版 vs 队列版），对比边界行为；  
    - 为 [1052] 绘制“基础满意度 + 滑窗增量”示意图，固化状态分离思维；  
    - 对 [3439] 进行问题重述训练：从题干提取“可滑动资源序列”；  
  - 推进灵神题单：  
    - [3694] 最多 K 次操作后的最大分数（预判为变长滑窗 + 哈希频次控制）；  
    - [3652] 恰好移动 k 步到达某位置的方法数（可能为 DP，需先确认是否含滑窗）；  
    - [2134] 最少侧跳次数（典型多状态滑窗/DP，分析车道切换的局部决策）；  
  - 完善**滑动窗口决策树**新增分支：  
    - 问题是否包含**不可变基础收益 + 可变窗口收益**？ → 是 → 分离计算；  
    - 操作对象是否为**派生序列**（如空余时间、差分数组）？ → 是 → 先转换再滑窗；  
    - 丢弃/保留决策是否**仅依赖当前窗口状态**？ → 是 → 用队列显式维护保留集。
   
### Day 7 - 回归基础与认知边界校准  

- **完成题目**：  
  - [x] [3694] 删除子字符串后不同的终点  
  - [x] [3652] 按策略买股票的最佳时机  

- **学习重点**：  
  - **状态建模能力仍待夯实**：  
    - [3694] 的核心障碍在于**未能将二维路径终点映射为可哈希的标量**。题解中通过 `(x + n) << 32 | (y + n)` 实现坐标压缩，本质是**利用偏移量消除负坐标、再通过位拼接构造唯一键**。此技巧依赖对内存布局和整数表示的理解，暴露了我在“状态编码”层面的经验缺失；  
    - [3652] 虽属经典股票 DP，但因题干引入**冷却期/交易次数/持有状态等复合约束**，导致无法快速抽象出状态转移方程。关键在于未识别出“**每天仅三种状态：空仓、持仓、冷却**”，陷入细节逻辑而忽略状态机主干；  
  - **难度感知与策略调整**：  
    - 1700+ 分题目普遍要求**多状态 DP 或高维滑窗**，而当前阶段应聚焦**单一算法范式的深度掌握**；  
    - 股票类 DP 虽标为 1700+，但其本质是**状态机模板的变体**，需先熟练掌握基础状态定义（如 `hold[i]`, `sold[i]`），而非直接挑战带复杂约束的版本；  

- **卡点反思**：  
  - **[3694] 陷入“模拟执念”**：试图用 BFS/DFS 枚举所有删除方案，未意识到终点仅由**总位移 - 被删段位移**决定，更未想到用数学编码替代 `pair<int,int>` 哈希；  
  - **[3652] 状态定义模糊**：  
    - 误将“是否在冷却期”作为独立维度，导致状态爆炸；  
    - 未抓住“**卖出后自动进入冷却，冷却一天后变为空仓**”的转移链条，错误地添加冗余状态；  
    - 忽略股票 DP 的通用套路：**以“是否持有股票”为核心状态，其他约束转化为转移条件**；  
  - **难度误判导致挫败感累积**：连续两题无法独立解决，根源在于**跳过基础巩固阶段直接挑战高维问题**，违背“由简入繁”的学习规律；  

- **收获与改进**：  
  - **确立“难度阈值”意识**：1700 分是当前能力分水岭，**暂停高分题攻坚，回归 1400–1700 分区间夯实基础**；  
  - **强化“问题降维”训练**：  
    - 遇到复杂题干时，强制执行三步：① 手写小规模示例；② 提取核心操作（如“删除子串→终点变化”）；③ 匹配基础模型（如“定长子数组→滑窗”）；  
    - 对 [3694] 的坐标编码技巧，补充笔记：**当需哈希多维状态且标准库不支持时，优先考虑位拼接（确保各维度值域 < 2³²）或线性组合（如 `x * BASE + y`）**；  
    - 对 [3652] 类股票题，建立状态机模板：  
      ```cpp
      hold[i] = max(hold[i-1], empty[i-1] - price[i]); // 继续持 or 买入
      sold[i] = hold[i-1] + price[i];                  // 卖出
      empty[i] = max(empty[i-1], sold[i-1]);           // 冷却结束 or 继续空仓
      ```  
  - **接受“暂时看不懂”**：高约束股票题暂标记为“DP 进阶待办”，待完成基础 DP 专题（如 [121]~[123]）后再回溯；  
  - 更新策略：**高分题仅用于拓展视野，不纳入当日核心任务**；  

- **明日计划**：  
  - **全面转向 1700 分以下题目**：  
    - 优先完成灵神题单中标记为 **“基础滑动窗口”** 的题目（如 [121] 买卖股票最佳时机、[209] 最小长度子数组）；  
    - 若题单中 1700 分以下题目耗尽，则启动 **“不定长滑动窗口” 专题**（如 [3] 无重复字符最长子串、[76] 最小覆盖子串）；  
  - **建立“基础题验收标准”**：  
    - 能 10 分钟内写出无 bug 代码；  
    - 能口述三种变体（如固定长/不定长/带权重）；  
    - 能手绘窗口扩张/收缩的指针移动过程；  
  - **补充工具链**：  
    - 整理常用状态编码模板（坐标压缩、多维状态 flatten）；  
    - 制作“滑动窗口决策速查表”：输入问题特征 → 输出窗口类型 + 维护状态；  
    - 归纳股票 DP 五部曲：状态定义 → 转移方程 → 初始化 → 遍历顺序 → 返回值。  

### Day 8 - 不定长滑动窗口的建模与逆向思维训练  

- **完成题目**：  
  - [x] [3] 无重复字符的最长子串  
  - [x] [3090] 每个子字符串最多包含两个不同字符  
  - [x] [1493] 删掉一个元素以后全为 1 的最长子数组  

- **学习重点**：  
  - **掌握“不定长滑动窗口”的核心范式**：  
    - 区别于固定长度窗口（如 [209]），**不定长窗口以“满足某条件的最大/最小子数组”为目标**，其关键在于**右指针扩张、左指针收缩的触发条件**；  
    - [3] 和 [3090] 共享同一模板：**维护字符频次哈希表 + 当种类数 > k 时收缩左边界**，体现了“**窗口合法性由内部状态决定**”这一原则；  
    - [1493] 则引入了**约束转化思想**：原问题“删掉一个 0 后全为 1 的最长子数组” ⇨ “**最多包含一个 0 的最长子数组**”，将“删除操作”转化为“容错计数”，是典型的**问题等价重构**；  
  - **逆向思维能力初显但未内化**：  
    - 在 [1493] 中，未能第一时间识别“删一个 0” ≡ “允许一个 0 存在”，反映出对“**操作语义 → 状态约束**”的映射不敏感；  
    - 此类转换在滑窗题中极为常见（如“最多 K 次替换” ⇨ “窗口内主元素频次 ≥ len−K”），需建立“**操作即容错”直觉**；  

- **卡点反思**：  
  - **[1493] 陷入正向模拟陷阱**：  
    - 初始思路试图枚举每个 0 的删除位置，再向左右扩展，导致 O(n²) 复杂度且边界处理复杂；  
    - 未意识到“**一次遍历 + 维护含 0 个数 ≤1 的窗口**”即可覆盖所有可能，本质是**将离散操作连续化**；  
  - **窗口收缩逻辑模糊**：  
    - 在 [3090] 中，曾错误地在每次右扩后立即收缩，而非“仅当不合法时才收缩”，导致窗口过早缩小、答案偏小；  
    - 根本原因是对“**while vs if**”的使用场景混淆：**非法状态需 while 循环持续收缩，合法状态只需 if 或无需处理**；  
  - **状态维护粒度粗糙**：  
    - 初写 [3] 时用 `set` 而非 `unordered_map<char, int>`，无法区分“字符存在但已移出窗口”的情况，导致 left 指针移动错误；  
    - 暴露了对“**频次精确统计 vs 存在性判断**”的适用边界不清——滑窗中几乎总是需要频次，而非布尔标记；  

- **收获与改进**：  
  - **提炼不定长滑窗通用模板**：  
    ```cpp
    int left = 0, max_len = 0;
    unordered_map<T, int> freq;
    for (int right = 0; right < n; ++right) {
        freq[arr[right]]++;               // 扩张右边界
        while (!valid(freq)) {            // 窗口非法时持续收缩
            freq[arr[left]]--;
            if (freq[arr[left]] == 0) freq.erase(arr[left]);
            left++;
        }
        max_len = max(max_len, right - left + 1); // 更新答案（合法窗口）
    }
    ```  
    - 关键函数 `valid(freq)` 需根据题意定制（如 `freq.size() <= 2` 或 `count_zero <= 1`）；  
  - **强化“约束转化”训练**：  
    - 遇到“删除/替换/跳过”等操作时，强制自问：“**能否转化为窗口内允许的异常数量？**”；  
    - 建立常见转化对照表：  
      | 原操作 | 等价窗口约束 |  
      |--------|----------------|  
      | 删除一个元素 | 最多含 1 个异类 |  
      | 替换 K 次 | 主元素频次 ≥ len − K |  
      | 跳过 M 个障碍 | 异常点 ≤ M |  
  - **明确数据结构选型原则**：  
    - 滑窗中若需判断“是否可收缩”，必须能**精确知道移除某元素后状态是否恢复合法** → 必须用**频次哈希表**，而非集合；  
  - **接受“模板需微调”**：  
    - [1493] 实际要求子数组**至少含一个 1**（全 0 不合法），但因输入保证有 1，故无需特判；未来需注意**边界合法性校验**；
    - [无重复字符的最长子串](https://github.com/Gelise436b/endless-cheng-leetcode/blob/main/sliding-window/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2.md),[删掉一个元素以后全为1的最长子数组](https://github.com/Gelise436b/endless-cheng-leetcode/blob/main/sliding-window/%E5%88%A0%E6%8E%89%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E4%BB%A5%E5%90%8E%E5%85%A8%E4%B8%BA1%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84.md)

- **明日计划**：  
  - **巩固今日三题**：  
    - 重写 [3090] 与 [1493]，确保 8 分钟内无 bug 完成；  
    - 手绘 [1493] 的窗口移动过程，标注 `left`、`right`、`zero_count` 变化；  
  - **推进新题（均 ≤1700 分）**：  
    - [3634] 字符串中最多包含 K 个不同字符的子串（不定长滑窗直接应用）；  
    - [1208] 尽可能使字符串相等的最小操作次数（转化为“子数组和 ≤ maxCost”的滑窗）；  
    - [904] 水果成篮（经典“最多两类”滑窗，与 [3090] 同源）；  
  - **构建“滑窗决策树”初稿**：  
    - 输入：问题描述关键词（如“最长”、“最多 K 种”、“替换”）；  
    - 输出：窗口类型（定长/不定长）、状态维护方式（频次/前缀和）、收缩条件；  
  - **坚持难度纪律**：所有新题严格控制在 1700 分以下，高分题仅作题解阅读。

