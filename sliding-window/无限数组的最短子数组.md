

### 📝 单题笔记：[2875] 无限数组的最短子数组

#### 🎯 题意简述

* 给定数组 `nums`（下标从 0 开始）和整数 `target`；
* `infinite_nums` 是由 `nums` 无限循环拼接而成；
* **目标**：在 `infinite_nums` 中找出和为 `target` 的**最短子数组**长度；若不存在返回 -1。

> 💡 **核心特征**：数据是无限循环的，但解是有限的。

---

#### ❌ 初期误解（典型陷阱）

> **误解一**：“为了覆盖足够长的 target，我要开一个巨大的数组，比如长度为 `target * n`。”

* **后果**：内存爆炸 (MLE) 或超时 (TLE)。

> **误解二**：“既然是无限数组，我把 `nums` 拼成 `2*n` 跑滑动窗口就行了。”

* **后果**：**WA (Wrong Answer)**。
* **原因**：当 `target` 非常大（比如 ），而 `nums` 总和很小（比如 5）时，答案包含数亿个完整的 `nums`，光靠 `2*n` 的窗口根本凑不够 `target`。

✅ **正确认知**：大数由“整体”组成，小数才需要“拼凑”。


---

#### 🧠 正确建模思路（除法 + 取模滑窗）

1. **宏观拆解（数学法）**：
* 先算 `nums` 的总和 `totalSum`。
* **主体部分**：`target` 里包含多少个完整的数组？
* 数量 。
* 贡献长度 。


* **剩余部分**：`remainder = target % totalSum`。


2. **微观搜索（滑动窗口）**：
* 我们只需要在“接缝处”寻找和为 `remainder` 的最短子数组。
* **搜索范围**：`nums` + `nums`（长度 `2*n`）足以覆盖所有跨越边界的情况。
* **技巧**：不需要物理拷贝数组，使用 `index % n` 模拟循环数组。



---

#### 🛠 解法：数学 + 虚拟环形滑窗

```cpp
class Solution {
public:
    int minSizeSubarray(vector<int>& nums, int target) {
        long long totalSum = 0; // ⚠️ 必须用 long long 防止溢出
        for (int x : nums) totalSum += x;
        
        int n = nums.size();
        
        // --- 1. 宏观计算：处理包含完整数组的部分 ---
        // 如果 target 很大，先切掉其中的整数倍 totalSum
        long long k = target / totalSum; 
        int remainder = target % totalSum; // 剩下的零头，去滑窗里找

        if (remainder == 0) return k * n; // 刚好整除，无需滑窗

        // --- 2. 微观计算：在 2*n 长度内找 remainder ---
        int ans = INT_MAX;
        long long currentSum = 0;
        int left = 0;
        
        // 模拟遍历 2*n 长度的数组 (nums + nums)
        for (int right = 0; right < 2 * n; right++) {
            currentSum += nums[right % n]; // 🔥 核心技巧：取模模拟循环
            
            // 经典的求“最短子数组”滑窗逻辑 (LC 209)
            while (currentSum > remainder) {
                currentSum -= nums[left % n];
                left++;
            }
            
            if (currentSum == remainder) {
                ans = min(ans, right - left + 1);
            }
        }
        
        // --- 3. 结果合并 ---
        // 如果 ans 还是初始值，说明找不到 remainder，返回 -1
        // 否则：完整部分长度 + 零头部分最小长度
        return ans == INT_MAX ? -1 : (int)(k * n + ans);
    }
};

```

---

#### ⚠️ 易错点总结

| 错误类型 | 正确做法 |
| --- | --- |
| **忽视大 Target** | 必须先计算 `target / totalSum`，不能只在 `2*n` 里找 `target`。 |
| **数据溢出** | `totalSum` 和窗口内的 `sum` 必须用 `long long`，因为 `target` 可达 。 |
| **min 参数错误** | `ans = min(left, len)` 是错的❌；应该是 `ans = min(ans, len)`✅。 |
| **返回类型强转** | 最终计算长度可能很大，虽然题目返回 int，但中间计算最好注意类型匹配。 |
| **滑动窗口目标** | 滑动窗口找的是 `remainder`，而不是原始的 `target`。 |

---

#### 🌟 思想升华

* **化繁为简（取模技巧）**：
遇到“环形数组”或“无限拼接数组”的问题，**不要真的去复制数组**。
使用 `i % n` 可以让一维线性的数组瞬间拥有环形的逻辑结构，空间复杂度从  降为 。
* **分治思想**：
将问题分为“确定的部分”（整除部分）和“不确定的部分”（取模部分）。
* 确定的用数学算 。
* 不确定的用算法搜 。



---

#### 🔁 对比同类题

| 题目 | 数组形态 | 核心技巧 |
| --- | --- | --- |
| [209] 长度最小的子数组 | 普通数组 | 标准滑动窗口 |
| [189] 轮转数组 | 普通数组 | `(i + k) % n` 下标映射 |
| **[2875] 无限数组最短子数组** | **无限/环形** | **Math (Div) + Sliding Window (Mod)** |

> 📌 **一句话总结**：
> **“大数靠除法，小数靠取模；不用真复制，下标转圈圈。”**
