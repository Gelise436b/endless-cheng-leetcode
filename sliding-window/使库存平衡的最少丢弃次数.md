
---

### 📝 单题笔记：[3679] 使库存平衡的最少丢弃次数

#### 🎯 题意简述  
- 给定数组 `arrivals`，其中 `arrivals[i]` 表示第 `i` 天到达的物品类型；  
- 有两个参数：窗口长度 `w`，最大保留频次 `m`；  
- **规则**：  
  - 每天可选择**保留或丢弃**当天物品（丢弃仅限当天）；  
  - 对任意天 `i`，在最近 `w` 天窗口 `[max(0, i−w+1), i]` 内，**被保留的物品中，每种类型出现次数 ≤ m**；  
  - 若保留当前物品会导致其在窗口内超限 → **必须丢弃**；  
- **目标**：求满足条件的**最少丢弃次数**。

> 💡 核心约束：**限制作用于“被保留的物品”构成的滑动窗口**，丢弃的物品不计入任何窗口。

---

#### ❌ 初期误解（典型陷阱）
> “一旦某类型累计保留达 `m` 次，后续同类型物品一律丢弃。”

**错误原因**：  
- 限制是**窗口局部的**，非全局；  
- 过期物品（滑出窗口）不再计入，同类型可再次保留；  
- 丢弃决策仅取决于**当前窗口内已保留的同类型数量**，与历史无关。

✅ 正确认知：**每次独立判断，能保留就保留，仅当保留会超限时才丢弃本次。**

---

#### 🧠 正确建模思路
1. **维护一个滑动窗口**，但窗口内只包含**被保留的物品**（丢弃的不入窗）；  
2. 窗口最大长度为 `w`（最近 `w` 天）；  
3. 对每个新物品：
   - 若窗口已满（size == w），先弹出最旧保留物品，并更新其类型计数；
   - 若当前类型在窗口中的保留数 `< m` → 保留（入队 + 计数++）；
   - 否则 → 丢弃（答案++，不入队）；

> ⚠️ 注意：**不能直接用 `arrivals` 下标作为窗口边界**，因为丢弃的物品不占窗口位置！

---

#### 🛠 解法一：显式队列（推荐，鲁棒清晰）
```cpp
class Solution {
public:
    int minArrivalsToDiscard(vector<int>& arrivals, int w, int m) {
        queue<int> kept; // 存放被保留的物品类型
        unordered_map<int, int> cnt;
        int discard = 0;

        for (int x : arrivals) {
            // 窗口已满，移除最旧保留项
            if (kept.size() == w) {
                int old = kept.front();
                kept.pop();
                cnt[old]--;
            }

            // 尝试保留当前物品
            if (cnt[x] < m) {
                kept.push(x);
                cnt[x]++;
            } else {
                discard++;
            }
        }
        return discard;
    }
};
```

---

#### 🛠 解法二：Hack 版（修改输入数组，依赖特殊值）
```cpp
class Solution {
public:
    int minArrivalsToDiscard(vector<int>& arrivals, int w, int m) {
        unordered_map<int, int> cnt;
        int ans = 0;
        for (int i = 0; i < arrivals.size(); i++) {
            int& x = arrivals[i];
            if (cnt[x] == m) {
                x = 0;      // 标记为丢弃（假设输入不含 0）
                ans++;
            } else {
                cnt[x]++;
            }

            int left = i - w + 1;
            if (left >= 0) {
                cnt[arrivals[left]]--;  // 若为 0，则减 cnt[0]，无害
            }
        }
        return ans;
    }
};
```

> ✅ **Hack 原理**：  
> - 丢弃时将 `arrivals[i]` 改为 `0`；  
> - 当该位置滑出窗口时，执行 `cnt[0]--`，不影响真实类型计数；  
>   
> ⚠️ **风险**：若原始 `arrivals` 包含 `0`，则 `cnt[0]` 被污染，结果错误。

---

#### ⚠️ 易错点总结
| 错误类型 | 正确做法 |
|--------|--------|
| 用全局计数代替窗口计数 | 必须只统计**最近 w 天内被保留的物品** |
| 丢弃后仍从 `cnt` 中减去 | 丢弃物品**不入 `cnt`**，滑出时也不应减（Hack 版通过改值规避） |
| 窗口边界按原始天数计算 | 窗口大小由**保留物品数量**决定，非原始下标 |
| 未处理 `cnt` 中零频次键 | 若用 `map.size()` 判断种类需 `erase`，但本题无需 |

---

#### 🌟 思想升华
- **滑窗对象决定解法**：本题窗口内容 = **保留序列**，而非原始数组；  
- **状态最小化原则**：只需维护 `cnt` 和窗口大小，无需记录具体位置；  
- **Hack vs 清晰**：竞赛可接受 Hack，工程/学习推荐显式队列；  
- **问题本质**：**贪心模拟 + 定长滑窗（保留队列）**，非复杂数据结构。

---

#### 🔁 对比同类题
| 题目 | 窗口作用对象 | 优化目标 |
|------|-------------|--------|
| [1151] 最少交换使 1 聚合 | 原始数组（固定窗口） | 窗口内 0 的最小数量 |
| [2107] 分享 k 个糖果 | 剩余集合（窗口外部） | 剩余种类数最大 |
| **[3679]** 库存平衡 | **保留序列（动态窗口）** | **丢弃次数最少** |

> ✅ 共性：**明确“什么在窗口里”是解题第一步。**

---

> 📌 **一句话总结**：  
> **“保留才计数，丢弃不入窗；窗口看最近 w 天保留项，超限才丢当前。”**

