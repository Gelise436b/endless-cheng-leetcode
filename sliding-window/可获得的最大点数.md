### 📝 LeetCode [1423] 可获得的最大点数 —— 单题精研笔记  

> **难度**：Medium  
> **标签**：数组、滑动窗口、前缀和、逆向思维、双端选取  
> **核心洞察**：从数组两端取 `k` 个元素的最大和，等价于**在中间连续 `n−k` 个元素中找最小和（补集思想）**，或**枚举所有“前 i + 后 k−i”组合中的最大值**。

---

#### 🔍 题意简述
给定整数数组 `cardPoints`，每次只能从**最左或最右**拿一张卡牌，共拿 `k` 次。求能获得的**最大点数总和**。

> 关键限制：操作具有**对称性**与**不可回溯性**——一旦开始取，剩余未取部分必为**中间一段连续子数组**。

---

#### 💡 解法一：逆向思维 + 定长滑动窗口（推荐 ✅）

##### 🧠 思路
- 总共 `n` 张牌，取 `k` 张 ⇒ 剩下 `n−k` 张；
- 剩余牌**必定连续**（因为只从两端取）；
- 要使取走的点数最大 ⇨ 剩下的点数最小；
- 问题转化为：**在 `cardPoints` 中找长度为 `m = n−k` 的连续子数组，使其和最小**；
- 使用**定长滑动窗口**求最小窗口和，再用总和减去它即得答案。

##### ✅ 优势
- 时间复杂度：**O(n)**  
- 空间复杂度：**O(1)**  
- 代码简洁，逻辑清晰，复用经典滑窗模板。

##### ⚠️ 注意事项
- 若 `k == n`，则 `m = 0`，此时最小窗口和为 0，直接返回总和；
- 使用 `std::accumulate` 替代 `std::reduce` 更兼容（LeetCode 虽支持 C++17，但 `accumulate` 更通用）。

##### 📌 代码（优化版）
```cpp
class Solution {
public:
    int maxScore(vector<int>& cardPoints, int k) {
        int n = cardPoints.size();
        int m = n - k;
        if (m == 0) return accumulate(cardPoints.begin(), cardPoints.end(), 0);

        long long windowSum = accumulate(cardPoints.begin(), cardPoints.begin() + m, 0LL);
        long long minSum = windowSum;

        for (int i = m; i < n; ++i) {
            windowSum += cardPoints[i] - cardPoints[i - m];
            minSum = min(minSum, windowSum);
        }

        long long total = accumulate(cardPoints.begin(), cardPoints.end(), 0LL);
        return total - minSum;
    }
};
```

---

#### 💡 解法二：正向枚举 + 滑动更新（直观但需小心边界）

##### 🧠 思路
- 枚举所有合法取法：
  - 取前 `k` 张，后 `0` 张；
  - 取前 `k−1` 张，后 `1` 张；
  - …
  - 取前 `0` 张，后 `k` 张；
- 共 `k+1` 种情况；
- 初始计算“全取左边”的和；
- 每次将**最右边的一张加入**，同时**移除左边最后一张**，实现 O(1) 更新。

##### ✅ 优势
- 直接模拟题意，易于理解；
- 无需考虑“剩余部分”，思维更贴近问题描述。

##### ⚠️ 注意事项
- 循环 `i` 从 `1` 到 `k`（共 `k` 次更新，加上初始状态共 `k+1` 种）；
- 注意数组下标：  
  - 加入的是 `cardPoints[n - i]`（从右往左第 `i` 个）；  
  - 移除的是 `cardPoints[k - i]`（从左往右第 `k−i` 个，0-indexed）。

##### 📌 代码（清晰版）
```cpp
class Solution {
public:
    int maxScore(vector<int>& cardPoints, int k) {
        int n = cardPoints.size();
        long long sum = accumulate(cardPoints.begin(), cardPoints.begin() + k, 0LL);
        long long ans = sum;

        for (int i = 1; i <= k; ++i) {
            sum += cardPoints[n - i] - cardPoints[k - i];
            ans = max(ans, sum);
        }
        return ans;
    }
};
```

---

#### 🆚 两种方法对比

| 维度 | 逆向思维（滑窗） | 正向枚举 |
|------|------------------|--------|
| **时间复杂度** | O(n) | O(k) ≈ O(n) |
| **空间复杂度** | O(1) | O(1) |
| **思维难度** | 中（需补集转化） | 低（直接模拟） |
| **代码长度** | 稍长（需处理 m=0） | 更短 |
| **适用扩展** | 易推广到“最小代价保留”类问题 | 仅适用于双端取固定数量 |

> ✅ **推荐掌握逆向解法**：它体现了算法中“**转换视角**”的核心能力，是解决“两端操作”类问题的通用钥匙。

---

#### 🧩 关键认知收获
1. **“从两端取 k 个” ⇨ “中间剩 n−k 个连续”** 是本题的**题眼**；
2. **滑动窗口不仅用于“找子数组”，也可用于“排除子数组”**；
3. `std::reduce` 是 C++17 的并行求和函数，但在算法题中**优先使用 `std::accumulate`** 避免兼容问题；
4. 正向枚举虽直观，但**逆向建模往往带来更优结构**。

---

#### 🔗 相关题目拓展
- [1658] 将 x 减到 0 的最小操作数（同构：两端取和为 x ⇒ 中间剩 sum−x）
- [2107] 含特定字符的子序列数目（非滑窗，注意区分）
- [1151] 最少交换次数使数组相等（环形滑窗）
