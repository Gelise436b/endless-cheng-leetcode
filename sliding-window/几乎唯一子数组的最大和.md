### 单题笔记：[2841] 几乎唯一子数组的最大和  

---

#### 🔍 题目核心  
给定整数数组 `nums` 和两个整数 `m`、`k`，找出**长度恰好为 `k`** 的连续子数组，使得其中**不同元素的种类数 ≥ m**（即“几乎唯一”），在所有满足条件的子数组中，返回**元素和的最大值**。

> 关键词：“固定长度” + “不同元素种类数 ≥ m” + “最大和” → **定长滑动窗口 + 哈希计数**

---

#### 🧠 解题思路  

1. **滑动窗口三步法**（窗口长度 = `k`）：
   - **进入**：将右端点 `nums[i]` 加入窗口（更新和 `s` 与频次 `cnt`）；
   - **更新**：当窗口达到长度 `k`（即 `i ≥ k - 1`），若 `cnt.size() >= m`，则用当前和 `s` 更新答案；
   - **退出**：移除最左侧元素 `nums[i - k + 1]`，为下一轮滑动做准备。

2. **如何判断“不同元素种类数 ≥ m”？**  
   - 使用 `map<int, int> cnt` 动态维护当前窗口中各元素的出现次数；
   - **`cnt.size()` 即为当前窗口中不同元素的种类数**；
   - ⚠️ **必须在计数归零时 `erase` 键**，否则 `size()` 会包含已不在窗口中的元素，导致误判！

3. **数据类型安全**：  
   - 窗口和 `s` 与答案 `ans` 均使用 `long long`，防止大数溢出。

---

#### ✅ 正确代码（带注释）

```cpp
class Solution {
public:
    long long maxSum(vector<int>& nums, int m, int k) {
        long long ans = 0, s = 0;
        map<int, int> cnt; // 记录窗口内各元素频次

        for (int i = 0; i < nums.size(); ++i) {
            // 1. 进入：加入右端点
            s += nums[i];
            cnt[nums[i]]++;

            int left = i - k + 1; // 当前窗口左边界
            if (left < 0) continue; // 窗口未满，跳过更新与退出

            // 2. 更新：窗口已满，检查是否“几乎唯一”
            if (cnt.size() >= m) {
                ans = max(ans, s);
            }

            // 3. 退出：移出左端点，为下一轮准备
            int out = nums[left];
            s -= out;
            if (--cnt[out] == 0) {
                cnt.erase(out); // 关键！避免 size() 虚高
            }
        }
        return ans;
    }
};
```

---

#### ⚠️ 易错点 & 关键细节  

| 问题 | 说明 |
|------|------|
| **忘记 `erase`** | 若不删除频次为 0 的键，`cnt.size()` 会包含“已离开窗口”的元素，导致错误认为种类数 ≥ m，从而误更新答案。 |
| **窗口长度误判** | 窗口满的条件是 `i >= k - 1`，对应左边界 `left = i - k + 1 ≥ 0`。 |
| **提前退出操作** | “退出”必须放在“更新”之后，且仅在窗口有效时执行，否则会访问负下标或污染状态。 |
| **使用 `unordered_map`？** | 可以，但本题对顺序无要求，`map` 或 `unordered_map` 均可；LeetCode 上 `unordered_map` 通常更快。 |

---

#### 💡 思维提炼  

- **“不同元素种类数”类问题 → 哈希表 + `size()` 是黄金组合**；
- **滑动窗口中哈希表的维护必须“进出对称”**：进时 `++`，出时 `--` 并 `erase`（若归零）；
- **定长窗口问题，永远围绕“右指针驱动，左指针滞后”展开**，无需显式维护双指针。

---

#### 📌 扩展思考  

- 若题目改为“**恰好 m 种不同元素**”，只需将条件改为 `cnt.size() == m`；
- 若窗口长度不固定，则需转为**变长滑动窗口**（如 [3] 无重复字符的最长子串）；
- 本题是 **“定长窗口 + 复杂合法性判定”** 的典型代表，后续遇到类似结构（如 [1100]）可直接套用此范式。

> ✨ **一句话总结**：  
> **“几乎唯一” = 种类数 ≥ m → 用 map 统计，靠 size 判断，凭 erase 保真。**
