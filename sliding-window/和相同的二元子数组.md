# [930] 和相同的二元子数组 (Binary Subarrays With Sum)

* **标签**：`Sliding Window` `Prefix Sum` `Two Pointers`
* **核心考点**：**定值滑窗模型的转换**、**对 0 的处理**

## 1. 题目“黑话”翻译

* **黑话**：“统计和为 `goal` 的非空子数组数量”。
* **人话**：因为数组里只有 `0` 和 `1`，其实就是找 **“包含 `goal` 个 1 的子数组”** 有多少个。
* **难点**：如果数组里全是 1，那很简单；但因为有 **0** 的存在（比如 `[1,0,0,1]`），导致窗口拉伸时和不一定增加，收缩时不一定减少，标准的“等于 K”滑窗逻辑会失效（不知道该不该缩左边界）。

## 2. 解题思路：通用模板 (atMost 模型)

这是解决所有 **“恰好 K 个” (Exact K)** 问题的杀手锏。

### **公式推导**

* **为什么要转换？**
* 求“和 **恰好** 为 K”很难，因为左右边界的移动逻辑不明确（尤其是有 0 的时候）。
* 求“和 **不超过** K”非常简单！因为条件变成了单调的：**只要 `sum > K`，左边界就必须收缩**。逻辑非常清晰。



### **模板逻辑深度解析 (`helper` 函数)**

我们需要实现一个 `atMost(nums, k)` 函数：

1. **进窗口 (`right`)**：`sum += nums[right]`。
2. **出窗口 (`left`)**：**严格的单调逻辑**。只要 `sum > k`，必须缩左边界 `sum -= nums[left++]`。这里不需要考虑 0 的干扰，反正大了就缩。
3. **核心计数 (`count`)**：`ans += right - left + 1`。
* **原理**：以 `right` 为结尾，`left` 为起始的窗口 `[left, right]` 满足和 `<= k`。
* 那么，`[left+1, right]`, `[left+2, right]`, ... `[right, right]` 这些子数组的和肯定更小，也一定满足 `<= k`。
* 所以，当前 `right` 位置贡献的合法子数组数量就是窗口长度。



## 3. 代码实现 (C++)

```cpp
class Solution {
public:
    int numSubarraysWithSum(vector<int>& nums, int goal) {
        // 恰好 K = 至多 K - 至多 K-1
        return atMost(nums, goal) - atMost(nums, goal - 1);
    }

    // 通用模板：统计和 <= k 的子数组数量
    int atMost(vector<int>& nums, int k) {
        if (k < 0) return 0; // 边界情况处理
        
        int left = 0, right = 0;
        int sum = 0;
        int ans = 0;
        
        while (right < nums.size()) {
            // 1. 进窗口
            sum += nums[right];
            
            // 2. 出窗口（维护 sum <= k）
            while (sum > k) {
                sum -= nums[left];
                left++;
            }
            
            // 3. 统计（累加当前窗口的有效子数组数量）
            // right - left + 1 代表以 nums[right] 结尾的、和不超过 k 的所有子数组
            ans += right - left + 1;
            
            right++;
        }
        return ans;
    }
};

```

## 4. 另一种视角：前缀和 + 哈希表

如果不强制用滑窗，这题其实是经典的 **Two Sum** 变体。

* **逻辑**：`CurrentPrefixSum - TargetPrefixSum = goal`  =>  `TargetPrefixSum = CurrentPrefixSum - goal`。
* **代码简述**：
```cpp
unordered_map<int, int> cnt;
cnt[0] = 1; // 也就是前缀和为0的情况出现过1次（还没开始遍历前）
int sum = 0, ans = 0;
for (int x : nums) {
    sum += x;
    ans += cnt[sum - goal]; // 找前面有多少个前缀和满足条件
    cnt[sum]++;
}

```


* **对比**：前缀和方法空间复杂度 O(N)，滑窗 O(1)。推荐掌握滑窗模板，因为 **[992] K 个不同整数** 只能用滑窗思路做，前缀和搞不定。

## 5. 易错点与反思

* **Corner Case**：调用 `atMost(goal - 1)` 时，如果 `goal` 是 0，传入 -1。在 `atMost` 函数开头必须加 `if (k < 0) return 0;`。
* **误区**：在 `atMost` 里写 `if (sum == k) count++`。
* **纠正**：`atMost` 统计的是所有 `<= k` 的情况，不要去特判等于。等于的情况是通过两个 `atMost` 相减得出来的。



## 6. 关联题目

* **[1248] 统计「优美子数组」**：完全一样。把奇数看成 1，偶数看成 0，代码直接复制过去就能过。
* **[992] K 个不同整数的子数组**：把 `sum` 的条件换成 `map.size()`，逻辑完全一致。
