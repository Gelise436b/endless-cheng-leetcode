

### 📌 [3634] 使数组平衡的最少移除数目（Medium）

#### 🔍 题意
给定整数数组 `nums` 和整数 `k`，移除最少的元素，使得剩余元素满足：  
> **最大值 ≤ 最小值 × k**

返回**最少移除数量**。

---

#### 💡 关键洞察（你的卡点）
- **不要求保留原顺序** → 可对数组排序；
- 排序后，任意合法子集在值域上必是**连续的一段**（否则中间空缺可填补以扩大集合）；
- 问题转化为：在**排序后的数组中找最长子数组** `[l, r]`，满足  
  `nums[r] ≤ nums[l] * k`。

---

#### ✅ 解法：排序 + 不定长滑动窗口

```cpp
int minRemoval(vector<int>& nums, int k) {
    sort(nums.begin(), nums.end());
    int max_save = 0, left = 0;
    for (int i = 0; i < nums.size(); i++) {
        // 收缩左边界直到窗口合法
        while (1LL * nums[left] * k < nums[i]) {
            left++;
        }
        max_save = max(max_save, i - left + 1);
    }
    return nums.size() - max_save; // 总数 - 最多保留 = 最少删除
}
```

---

#### ⚠️ 注意事项
- **必须用 `1LL * ...` 防止乘法溢出**（k 和 nums[i] 可达 1e9）；
- **窗口收缩用 `while`**：一次 `left++` 可能不足以恢复合法性；
- **答案 = n − 最长合法窗口长度**，体现“最少删 ⇨ 最多留”思想。

---

#### 🧠 反思总结
> 初期误以为需保持原始顺序，试图在无序数组中找满足条件的子集，复杂且无效。  
> **一旦意识到“只要结果、不要过程”，即可自由排序，将组合问题转为区间问题**——这是本题突破口。

---

#### 🏷️ 标签
`贪心` `排序` `滑动窗口` `数学约束` `Medium`

--- 
