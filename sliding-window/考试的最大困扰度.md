【2024 · 考试的最大困扰度】  
关键词：最小化「最大连续更换次数」→ 二分答案 + 定长滑窗验证  

### 一、题意压缩  
- 给定长度为 `n` 的 `answerKey`（仅含 `'T'` / `'F'`）  
- 可更换最多 `k` 次字符（`'T'↔'F'` 任意）  
- 求：经过更换后，**最长的「连续相同答案」段**至少能是多少？  
  （题目原话是“最小化最大困扰度”，即让最长的连续相同段尽可能短）  

> 反向理解：求**最小的 `maxLen`**，使得存在一段长度 `maxLen` 的连续题号，其中需要更换的次数 ≤ `k`。

### 二、题型判定  
1. 最小化最大值 → 二分答案  
2. 验证「是否存在长度 = `mid` 的段，更换次数 ≤ `k`」→ 定长滑窗 O(n)  

### 三、二分框架  
```cpp
int low = 1, high = n, ans = n;
while (low <= high) {
    int mid = (low + high) / 2;
    if (check(mid)) {          // 能找到长度=mid且更换≤k的段
        ans = mid;             // 尝试更小
        high = mid - 1;
    } else {
        low = mid + 1;         // 必须放宽
    }
}
return ans;
```

### 四、定长滑窗验证 `check(mid)`  
核心观察：  
- 任意长度为 `mid` 的段，把**少数派**全部换掉即可统一成同一种答案；  
- 需要更换次数 = `min(段内T个数, 段内F个数)`；  
- 只要有一段的更换次数 ≤ `k`，`mid` 就可行。

```cpp
bool check(int mid) {
    int cntT = 0, cntF = 0;
    // 初窗 [0..mid-1]
    for (int i = 0; i < mid; ++i) {
        if (answerKey[i] == 'T') ++cntT;
        else                     ++cntF;
    }
    if (min(cntT, cntF) <= k) return true;

    // 滑动窗口
    for (int i = mid; i < n; ++i) {
        // 右端新进
        if (answerKey[i] == 'T') ++cntT;
        else                     ++cntF;
        // 左端离开
        if (answerKey[i - mid] == 'T') --cntT;
        else                           --cntF;
        // 检查
        if (min(cntT, cntF) <= k) return true;
    }
    return false;
}
```

### 五、完整代码（C++17）
```cpp
class Solution {
public:
    int maxConsecutiveAnswers(string answerKey, int k) {
        int n = answerKey.size();
        int low = 1, high = n, ans = n;
        
        auto check = [&](int mid) {
            int cntT = 0, cntF = 0;
            for (int i = 0; i < mid; ++i) {
                if (answerKey[i] == 'T') ++cntT;
                else                     ++cntF;
            }
            if (min(cntT, cntF) <= k) return true;
            
            for (int i = mid; i < n; ++i) {
                if (answerKey[i] == 'T') ++cntT;
                else                     ++cntF;
                if (answerKey[i - mid] == 'T') --cntT;
                else                           --cntF;
                if (min(cntT, cntF) <= k) return true;
            }
            return false;
        };

        while (low <= high) {
            int mid = (low + high) / 2;
            if (check(mid)) {
                ans = mid;
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        return ans;          // 最长连续相同段的最小可能值
    }
};
```

### 六、复杂度  
- 时间：O(n log n)  
- 空间：O(1)  

### 七、易错小结  
1. 把「最小化最大值」认出二分答案；  
2. `check` 里维护的是**定长窗口**而非不定长；  
3. 更换次数 = 少数派数量，即 `min(cntT, cntF)`；  
4. 二分输出的是「最小可能的最大连续长度」，不要返回 `low` 或 `high`，用 `ans` 保存。
