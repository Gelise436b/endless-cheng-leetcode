

### 📝 单题笔记：[76] 最小覆盖子串

#### 🎯 题意简述

* 给定字符串 `s` 和 `t`；
* 在 `s` 中找出**最短**的子串，包含 `t` 中所有字符（包括重复字符的数量）；
* 例如 `t = "AABC"`, 那么子串里至少得有 2个A，1个B，1个C。

---

#### ❌ 初期思路（你的第一版代码）

> **“双哈希表 + 笨拙检查”**

* 维护两个数组：`cnt_t`（目标）和 `cnt_s`（当前窗口）。
* 每次窗口滑动后，写一个 `is_covered()` 函数，循环 52 次（A-Z, a-z）对比两个数组。
* **缺点**：虽然能过，但这增加了巨大的常数开销（每次移动都要遍历 52 次），且代码写起来很啰嗦。

#### 🧠 进阶建模（你的第二版代码）

> **“单数组差分 + 变量维护”**

我们不需要两个数组对比，只需要一张**“欠条”**。

1. **合并数组（差分思想）**：
* 只用一个 `cnt` 数组。
* **正数**代表**“欠债”**（`t` 里有，但我窗口里还没凑够）。
* **0** 代表**“收支平衡”**（刚好凑够）。
* **负数**代表**“盈余”**（窗口里多了，虽然多了不影响覆盖，但在收缩窗口时是重要参考）。


2. **核心变量 `less`（关键优化）**：
* 你原本在 `is_covered` 里遍历 128 个字符，只是为了问一个问题：“都凑齐了吗？”
* 我们定义一个变量 `less`：**当前还有几种字符（种类）没凑齐？**
* **入窗 (`right`)**：如果某字符还完债了（`cnt` 减到 0），`less` 就减 1。
* **出窗 (`left`)**：如果某字符从“平衡”变成了“欠债”（`cnt` 从 0 变回 1），`less` 就加 1。
* **判断条件**：只要 `less == 0`，就说明所有债都还完了（即 `is_covered` 为真）。



---

#### 🛠 解法：滑动窗口 + 记账法

```cpp
class Solution {
public:
    string minWindow(string s, string t) {
        int cnt[128]{};
        int less = 0; // 代表“还有几种字符没凑齐”

        // 1. 初始化欠条
        // 统计 t 中每个字符的数量，cnt 为正数表示“欠债”
        for(char c : t) {
            if (cnt[c] == 0) less++; // 这是一个新的欠债种类
            cnt[c]++;
        }

        int m = s.size();
        int ans_left = -1, ans_right = m;
        int left = 0;

        // 2. 滑动窗口
        for (int right = 0; right < m; right++) {
            char c = s[right];
            cnt[c]--; // 遇到一个字符，还一个债
            
            // 关键点 A：如果这个字符的债务刚好还清（从 1 减到 0）
            // 说明这一“种”字符凑齐了，less 减 1
            if(cnt[c] == 0) {
                less--;
            }

            // 3. 收缩窗口 (只要 less == 0，说明当前窗口合法)
            while (less == 0) {
                // 更新答案
                if (right - left < ans_right - ans_left) {
                    ans_left = left;
                    ans_right = right;
                }

                char x = s[left];
                // 关键点 B：我们要踢出 x，看看会不会导致“欠债”
                // 如果当前 cnt[x] == 0，说明本来是刚好的，踢了就变欠债了
                if (cnt[x] == 0) {
                    less++; // 欠债种类 +1，导致循环会结束
                }
                cnt[x]++; // 踢出字符，把债加回去
                left++;
            }
        }
        return ans_left < 0 ? "" : s.substr(ans_left, ans_right - ans_left + 1);
    }
};

```

---

#### ⚠️ 易错点总结

| 错误类型 | 你的写法逻辑 | 常见另一种写法 |
| --- | --- | --- |
| **less 的定义** | 统计**“未完成的种类数”**。 | 统计**“已完成的总字符个数”**。 |
| **入窗逻辑** | `cnt--`，若 `cnt==0` 则 `less--`。 | `cnt--`，若 `cnt>=0` 则 `count++`。 |
| **出窗逻辑** | 若 `cnt==0` 则 `less++`，然后 `cnt++`。 | 若 `cnt==0` 则 `count--`，然后 `cnt++`。 |

> **你的这种写法（种类统计）其实更清晰**：
> 因为它利用了 `cnt` 为 0 这个特殊状态作为**“临界点”**。
> * `cnt` 从 1 -> 0：**达标**（`less--`）。
> * `cnt` 从 0 -> 1：**破防**（`less++`）。
> * `cnt` 从 -1 -> 0：只是把多余的扔了，依然达标（`less` 不变）。
> 
> 

---

#### 🌟 思想升华

* **降维打击**：
把“遍历数组检查状态” () 优化为 “维护一个整数变量” ()。这是所有“状态检查类”滑动窗口题的通用优化手段。
* **正负的艺术**：
不要用两个 Map。



我们只维护这个 `Diff`。正数是缺，负数是多，0 是完美。

#### 🔁 对比同类题

| 题目 | 维护的状态 | 判据 |
| --- | --- | --- |
| [438] 找到字符串中所有字母异位词 | 也是覆盖所有字符 | 窗口长度固定 + `less == 0` |
| [76] 最小覆盖子串 | 覆盖所有字符 | 窗口变长 + `less == 0` 取最小 |
| [3] 无重复字符的最长子串 | 不允许重复 | `cnt[c] > 1` 为非法 |

> 📌 **一句话总结**：
> **“两个Map太啰嗦，一个数组做差分；正数欠债负数盈，less归零即还清。”**
