

### 📝 单题笔记：[1234] 替换子串得到平衡字符串

#### 🎯 题意简述

* 给定字符串 `s`（仅含 Q, W, E, R），长度 `n` 是 4 的倍数；
* 目标：将每个字母的出现次数调整为 `m = n/4`；
* 手段：选择**一个**子串（连续区间），将其中的字符任意替换；
* **要求**：求满足条件的**最小子串长度**。

> 💡 **核心转换**：题目问的是“怎么改子串”，实际上等价于“**子串之外剩下的部分要满足什么条件**”。

---

#### ❌ 初期误解（典型陷阱）

> “我要算出每种字母多了几个，然后在字符串里找一个包含这些多余字母的最小子串。”

**思维误区**：

* 容易陷入“缺什么补什么”的正向思维，试图在窗口里凑齐多余的字母。
* **难点**：多余的字母可能分布得非常散，单纯找“包含所有多余字母的子串”很难处理逻辑。

✅ **正确认知**：我们不需要关心子串里填什么（那是填空题，随便填），我们只需要关心**子串之外**（不可修改区域）是否**没有超标**。

---

#### 🧠 正确建模思路（逆向思维 / 补集思想）

1. **定义区域**：
* **外部（不可变区域）**：窗口 `[left, right]` 之外的部分。我们无法修改这里面的字母。
* **内部（可变区域）**：窗口 `[left, right]` 之内的部分。我们可以把它变成任何我们要的样子。


2. **核心判据**：
* 如果**外部**某字母数量 `> m`  没救了。外部已经超标，内部怎么改都无法把总数降下来。说明**窗口太小**（没把多余的覆盖住）。
* 如果**外部**所有字母数量 `≤ m`  有救。外部没满，空缺的部分完全可以通过修改内部（可变区域）来填补。说明**窗口合法**（尝试缩小以求最优解）。


3. **算法映射**：
* 维护一个统计数组 `cnt`，记录**当前窗口之外**的字符频率。



---

#### 🛠 解法：逆向滑动窗口

```cpp
class Solution {
public:
    int balancedString(string s) {
        int cnt['X']{}; 
        for(char c:s) cnt[c]++; // 初始化：此时窗口为空，cnt 代表全集

        int n = s.size(), m = n / 4;
        // 特判：如果一开始就平衡，不需要替换
        if (cnt['Q']==m && cnt['W']==m && cnt['E']==m && cnt['R']==m) return 0;

        int ans = n, left = 0;
        
        // 滑动窗口 [left, right]
        for (int right = 0; right < n; right++) {
            // 1. 进窗 = 移出外部统计
            // s[right] 进入待替换区域，所以它不再属于“不可变的外部”，计数减 1
            cnt[s[right]]--; 

            // 2. 检查外部是否合法（都不超过 m）
            while (left <= right && cnt['Q'] <= m && cnt['W'] <= m && cnt['E'] <= m && cnt['R'] <= m) {
                ans = min(ans, right - left + 1);
                
                // 3. 出窗 = 回归外部统计
                // s[left] 离开待替换区域，变回“不可变的外部”，计数加 1
                cnt[s[left]]++; 
                left++;
            }
        }
        return ans;
    }
};

```

---

#### ⚠️ 易错点总结

| 错误类型 | 正确做法 |
| --- | --- |
| `cnt` 含义混淆 | 代码中的 `cnt` 始终维护**窗口之外**的字符数，而非窗口内。 |
| 忘记特判 0 | 如果原串本身就是平衡的，`while` 循环可能一次都不执行，需预先判断。 |
| 窗口收缩条件 | 只要 `cnt` 全 `≤ m` 就一直收缩 (`while`)，而不是只收缩一次 (`if`)。 |
| `cnt` 减法时机 | `right` 处字符**进窗**意味着它**不再是外部**，所以是 `cnt--`（这是最反直觉的地方）。 |

---

#### 🌟 思想升华

* **补集统计法**：
当关注的对象（窗口内）变化极其自由（可以变成任意字符），而背景（窗口外）是刚性约束时，**统计背景**比统计对象更简单。
* **复用统计数组**：
不需要开两个 Map (Inside/Outside)。
* `Total` - `In_Window` = `Outside`。
* 代码里直接操作总 `cnt`，进窗减、出窗加，实时维护的就是 `Outside`。



---

#### 🔁 对比同类题

| 题目 | 窗口维护内容 | 判据逻辑 |
| --- | --- | --- |
| [76] 最小覆盖子串 | 窗口**内** | 窗口内必须**包含**足够的 Target 字符 |
| **[1234] 替换子串** | 窗口**外** | 窗口外必须**不超过** Target 字符 |
| [1004] 最大连续1的个数 III | 窗口**内** | 窗口内 0 的个数不超过 K |

> 📌 **一句话总结**：
> **“只要外面不爆仓（>m），里面空位一定够补仓；进窗即从外面移除（`cnt--`），出窗即归还给外面（`cnt++`）。”**
